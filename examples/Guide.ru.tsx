
import React from 'react';
import { Sofa, Stack, Text, Accordion, AccordionItem, AccordionTrigger, AccordionContent, Markdown } from '../src/components';

// A comprehensive 50-module tutorial for beginners in Russian.
const modules = [
    {
        id: 'module-1',
        title: 'Модуль 1: Введение в веб-разработку',
        content: `
### Что такое веб-сайт?

Простыми словами, веб-сайт — это набор связанных веб-страниц, доступных в интернете. Когда вы вводите адрес в браузере (например, \`google.com\`), вы запрашиваете эти страницы с удаленного компьютера (сервера).

### Клиент и Сервер

- **Клиент (Client):** Это ваш веб-браузер (Chrome, Firefox, Safari). Он отправляет запросы на сервер и отображает (рендерит) полученный код в виде красивой веб-страницы.
- **Сервер (Server):** Это мощный компьютер, который хранит файлы веб-сайта и отправляет их клиенту по запросу.

### Три кита веб-разработки

Любая веб-страница, которую вы видите, построена на трех основных технологиях:

1.  **HTML (HyperText Markup Language):** Язык разметки, который определяет **структуру** и **содержимое** страницы. Это как скелет здания. Он говорит: "Здесь будет заголовок, здесь — абзац, а здесь — картинка".
2.  **CSS (Cascading Style Sheets):** Язык стилей, который описывает **внешний вид** страницы. Это как отделка и дизайн здания. Он говорит: "Заголовок будет синим и большим, а картинка будет с закругленными углами".
3.  **JavaScript (JS):** Язык программирования, который добавляет **интерактивность** и **динамику**. Это как электричество и сантехника в здании. Он позволяет реагировать на действия пользователя (клики, ввод текста), загружать данные без перезагрузки страницы и многое другое.
        `,
    },
    {
        id: 'module-2',
        title: 'Модуль 2: Основы HTML - Структура страницы',
        content: `
### Что такое HTML?

HTML — это не язык программирования, а **язык разметки**. Он использует **теги** для описания различных частей документа.

- **Тег (Tag):** Инструкция для браузера, заключенная в угловые скобки. Например, \`<p>\` — это тег для абзаца. Большинство тегов парные: открывающий (\`<p>\`) и закрывающий (\`</p>\`).
- **Элемент (Element):** Это полная конструкция, состоящая из открывающего тега, содержимого и закрывающего тега. Например: \`<p>Привет, мир!</p>\`.
- **Атрибут (Attribute):** Дополнительная информация для тега. Например, в теге \`<img src="photo.jpg">\` \`src\` — это атрибут, указывающий путь к картинке.

### Базовая структура HTML-документа

Каждый HTML-файл имеет следующую базовую структуру:

\`\`\`html
<!DOCTYPE html>
<html>
  <head>
    <title>Название страницы</title>
    <meta charset="UTF-8">
  </head>
  <body>
    <h1>Мой первый заголовок</h1>
    <p>Мой первый абзац.</p>
  </body>
</html>
\`\`\`

- \`<!DOCTYPE html>\`: Объявляет, что это HTML5-документ.
- \`<html>\`: Корневой элемент страницы.
- \`<head>\`: Содержит мета-информацию о странице (название, кодировка), которая не отображается напрямую.
- \`<body>\`: Содержит все видимое содержимое страницы.

### Ключевые теги содержимого

- \`<h1>\` - \`<h6>\`: Заголовки разных уровней (от самого важного до наименее важного).
- \`<p>\`: Абзац текста.
- \`<a>\`: Ссылка. Атрибут \`href\` указывает URL. Пример: \`<a href="https://google.com">Перейти в Google</a>\`.
- \`<img>\`: Изображение. Атрибут \`src\` указывает путь к файлу.
        `,
    },
    {
        id: 'module-3',
        title: 'Модуль 3: Больше HTML - Списки, таблицы и формы',
        content: `
### Списки (Lists)

Списки используются для группировки связанных элементов.

- **Неупорядоченный список (\`<ul>\`):** Список с маркерами.
  \`\`\`html
  <ul>
    <li>Элемент 1</li>
    <li>Элемент 2</li>
  </ul>
  \`\`\`
- **Упорядоченный список (\`<ol>\`):** Нумерованный список.
  \`\`\`html
  <ol>
    <li>Первый шаг</li>
    <li>Второй шаг</li>
  </ol>
  \`\`\`

### Таблицы (Tables)

Таблицы используются для представления данных в виде сетки.

- \`<table>\`: Контейнер для таблицы.
- \`<tr>\`: Ряд таблицы (table row).
- \`<th>\`: Заголовок столбца (table header).
- \`<td>\`: Ячейка данных (table data).

\`\`\`html
<table>
  <tr>
    <th>Имя</th>
    <th>Возраст</th>
  </tr>
  <tr>
    <td>Иван</td>
    <td>30</td>
  </tr>
</table>
\`\`\`

### Формы (Forms)

Формы нужны для сбора данных от пользователя.

- \`<form>\`: Контейнер для элементов формы.
- \`<input>\`: Самый универсальный элемент. Атрибут \`type\` определяет его вид (\`text\`, \`password\`, \`checkbox\`, \`submit\`).
- \`<textarea>\`: Многострочное текстовое поле.
- \`<button>\`: Кнопка.

\`\`\`html
<form>
  <label for="username">Имя:</label><br>
  <input type="text" id="username" name="username"><br>
  <label for="password">Пароль:</label><br>
  <input type="password" id="password" name="password"><br><br>
  <button type="submit">Отправить</button>
</form>
\`\`\`
        `,
    },
    {
        id: 'module-4',
        title: 'Модуль 4: Основы CSS - Стилизация вашей страницы',
        content: `
### Что такое CSS?

CSS (Cascading Style Sheets) — это язык, который мы используем, чтобы сделать наши HTML-страницы красивыми. Он позволяет управлять цветами, шрифтами, отступами, размерами и расположением элементов.

### Способы подключения CSS

1.  **Встроенные стили (Inline):** Прямо в HTML-теге через атрибут \`style\`. Плохая практика, используется редко.
    \`\`\`html
    <p style="color: blue;">Этот текст синий.</p>
    \`\`\`
2.  **Внутренние стили (Internal):** Внутри тега \`<style>\` в \`<head>\` документа.
    \`\`\`html
    <head>
      <style>
        p {
          color: blue;
        }
      </style>
    </head>
    \`\`\`
3.  **Внешние стили (External):** В отдельном \`.css\` файле. **Это лучший и самый распространенный способ.**
    \`\`\`html
    <!-- В index.html -->
    <head>
      <link rel="stylesheet" href="styles.css">
    </head>
    \`\`\`
    \`\`\`css
    /* В styles.css */
    p {
      color: blue;
    }
    \`\`\`

### CSS Селекторы

Селектор — это правило, которое определяет, к каким HTML-элементам применять стили.

- **По тегу:** \`p { ... }\` (все абзацы).
- **По классу:** \`.my-class { ... }\` (все элементы с \`class="my-class"\`).
- **По ID:** \`#my-id { ... }\` (элемент с \`id="my-id"\`).

### Основные свойства

- \`color\`: цвет текста.
- \`background-color\`: цвет фона.
- \`font-size\`: размер шрифта (например, \`16px\`).
- \`font-family\`: семейство шрифта (например, \`Arial, sans-serif\`).
- \`font-weight\`: жирность шрифта (например, \`bold\`).
        `,
    },
    {
        id: 'module-5',
        title: 'Модуль 5: CSS Box Model - Размеры и отступы',
        content: `
### Блочная модель (Box Model)

Каждый HTML-элемент в браузере можно представить как прямоугольный блок. У этого блока есть несколько слоев:

1.  **Содержимое (Content):** Текст, изображение или другой контент. Его размеры задаются свойствами \`width\` и \`height\`.
2.  **Внутренний отступ (Padding):** Пространство между содержимым и границей.
3.  **Граница (Border):** Линия вокруг содержимого и внутреннего отступа.
4.  **Внешний отступ (Margin):** Пространство вокруг элемента, которое отталкивает другие элементы.

\`\`\`css
.my-box {
  width: 200px;
  height: 100px;
  padding: 20px; /* Отступ со всех сторон */
  border: 1px solid black; /* Сплошная черная граница толщиной 1px */
  margin: 10px; /* Внешний отступ со всех сторон */
}
\`\`\`

### Свойство box-sizing

По умолчанию, \`width\` и \`height\` задают размеры только для *содержимого*. \`padding\` и \`border\` добавляются сверху, увеличивая реальный размер блока. Это неудобно.

Чтобы это исправить, используется свойство \`box-sizing: border-box;\`. С ним \`width\` и \`height\` будут включать в себя и \`padding\`, и \`border\`. Это делает верстку гораздо предсказуемее.

Хорошей практикой является установка этого свойства для всех элементов на странице:

\`\`\`css
* {
  box-sizing: border-box;
}
\`\`\`
        `,
    },
    {
        id: 'module-6',
        title: 'Модуль 6: CSS Flexbox - Гибкая верстка',
        content: `
### Что такое Flexbox?

Flexbox — это мощный инструмент в CSS для выравнивания и распределения элементов в контейнере. Он позволяет легко создавать гибкие и адаптивные макеты.

### Основные понятия

- **Flex-контейнер:** Элемент, к которому применяется \`display: flex;\`.
- **Flex-элементы:** Прямые дочерние элементы flex-контейнера.
- **Главная ось (Main Axis):** Направление, в котором располагаются элементы. По умолчанию — горизонтальное.
- **Поперечная ось (Cross Axis):** Ось, перпендикулярная главной.

### Ключевые свойства для Flex-контейнера

- \`display: flex;\`: Превращает элемент во flex-контейнер.
- \`flex-direction\`: Задает направление главной оси.
  - \`row\` (по умолчанию): горизонтально, слева направо.
  - \`column\`: вертикально, сверху вниз.
- \`justify-content\`: Выравнивание элементов вдоль **главной оси**.
  - \`flex-start\`, \`center\`, \`flex-end\`, \`space-between\`.
- \`align-items\`: Выравнивание элементов вдоль **поперечной оси**.
  - \`flex-start\`, \`center\`, \`flex-end\`, \`stretch\`.

### Пример

\`\`\`html
<div class="container">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
</div>
\`\`\`

\`\`\`css
.container {
  display: flex;
  justify-content: space-between; /* Распределить с равным пространством между */
  align-items: center; /* Выровнять по центру вертикально */
  background-color: #eee;
  padding: 10px;
}
.item {
  background-color: #3b82f6;
  color: white;
  padding: 20px;
}
\`\`\`
        `,
    },
    {
        id: 'module-7',
        title: 'Модуль 7: Основы JavaScript - Переменные и типы данных',
        content: `
### Что такое JavaScript?

JavaScript (JS) — это язык программирования, который позволяет оживить ваши веб-страницы. Если HTML — это скелет, а CSS — внешний вид, то JS — это мозг и мышцы.

### Подключение JavaScript

JS-код можно писать прямо в HTML-файле внутри тега \`<script>\`, но лучшая практика — выносить его в отдельный файл (например, \`script.js\`) и подключать так:
\`\`\`html
<script src="script.js"></script>
\`\`\`
Тег \`<script>\` обычно ставят в конце \`<body>\`, чтобы страница сначала загрузилась и отобразилась, а уже потом начал выполняться скрипт.

### Переменные

Переменная — это именованный контейнер для хранения данных. В современном JS для объявления переменных используются \`let\` и \`const\`.

- \`let\`: Для переменных, значение которых может меняться.
  \`\`\`javascript
  let age = 25;
  age = 26; // OK
  \`\`\`
- \`const\`: Для констант, значение которых не меняется.
  \`\`\`javascript
  const name = "Иван";
  // name = "Петр"; // Ошибка!
  \`\`\`
**Правило:** Всегда используйте \`const\`, если не планируете изменять значение переменной.

### Типы данных

- **String (строка):** Текст, заключенный в кавычки. \`'Привет'\` или \`"Мир"\`.
- **Number (число):** Целые числа и числа с плавающей точкой. \`10\`, \`3.14\`.
- **Boolean (логический):** \`true\` (истина) или \`false\` (ложь).
- **Object (объект):** Коллекция данных в формате "ключ: значение".
  \`\`\`javascript
  const user = {
    name: "Алиса",
    age: 30
  };
  \`\`\`
- **Array (массив):** Упорядоченная коллекция значений.
  \`\`\`javascript
  const colors = ["красный", "зеленый", "синий"];
  \`\`\`
        `,
    },
    {
        id: 'module-8',
        title: 'Модуль 8: JavaScript - Функции и события',
        content: `
### Функции (Functions)

Функция — это блок кода, который можно вызывать многократно. Она помогает организовать код и избежать повторений.

\`\`\`javascript
// Объявление функции
function greet(name) {
  console.log("Привет, " + name + "!");
}

// Вызов функции
greet("Мария"); // Выведет в консоль: "Привет, Мария!"
\`\`\`

Функция может принимать **параметры** (в примере это \`name\`) и **возвращать значение** с помощью ключевого слова \`return\`.

\`\`\`javascript
function add(a, b) {
  return a + b;
}

const sum = add(5, 3); // sum будет равно 8
\`\`\`

### События (Events)

События — это действия, которые происходят на веб-странице (клик мыши, нажатие клавиши, отправка формы). JavaScript может "слушать" эти события и выполнять код в ответ.

Для этого используется метод \`addEventListener\`.

\`\`\`html
<button id="myButton">Нажми меня</button>
\`\`\`

\`\`\`javascript
// 1. Находим кнопку в DOM
const button = document.getElementById('myButton');

// 2. Добавляем "слушателя" события 'click'
button.addEventListener('click', function() {
  // 3. Этот код выполнится при каждом клике
  alert('Кнопка была нажата!');
});
\`\`\`
        `,
    },
    {
        id: 'module-9',
        title: 'Модуль 9: JavaScript - Работа с DOM',
        content: `
### Что такое DOM?

DOM (Document Object Model) — это представление HTML-документа в виде дерева объектов. Каждый HTML-тег становится объектом в этом дереве. JavaScript может взаимодействовать с этими объектами, чтобы динамически изменять страницу.

### 1. Выбор элементов

Чтобы что-то изменить на странице, сначала нужно найти нужный элемент.

- \`document.getElementById('id-элемента')\`: Находит элемент по его уникальному \`id\`.
- \`document.querySelector('css-селектор')\`: Находит *первый* элемент, соответствующий CSS-селектору (например, \`.my-class\` или \`p\`).
- \`document.querySelectorAll('css-селектор')\`: Находит *все* элементы, соответствующие селектору, и возвращает их в виде коллекции.

### 2. Изменение содержимого

- \`.innerHTML\`: Позволяет читать или изменять HTML-содержимое внутри элемента.
  \`\`\`javascript
  const header = document.querySelector('h1');
  header.innerHTML = "<em>Новый</em> заголовок"; // текст станет курсивным
  \`\`\`
- \`.textContent\`: Работает только с текстом, игнорируя HTML-теги. Это безопаснее.
  \`\`\`javascript
  header.textContent = "Просто новый текст";
  \`\`\`

### 3. Изменение стилей

Стили элемента доступны через свойство \`style\`.

\`\`\`javascript
const paragraph = document.querySelector('p');
paragraph.style.color = 'red';
paragraph.style.fontSize = '20px'; // Свойства CSS пишутся в camelCase
\`\`\`

### 4. Изменение классов

Более правильный способ менять стили — это добавлять или удалять CSS-классы.

\`\`\`javascript
// Добавить класс
paragraph.classList.add('highlight');

// Удалить класс
paragraph.classList.remove('highlight');

// Переключить класс (если есть - удалит, если нет - добавит)
paragraph.classList.toggle('highlight');
\`\`\`
        `,
    },
    {
        id: 'module-10',
        title: 'Модуль 10: Современные инструменты - Node.js и npm',
        content: `
### Что такое Node.js?

Изначально JavaScript работал только в браузерах. **Node.js** — это среда выполнения, которая позволяет запускать JavaScript-код вне браузера, прямо на вашем компьютере.

Это открыло огромные возможности: на JavaScript теперь можно писать серверы, утилиты командной строки и, что самое важное для нас, — **инструменты для frontend-разработки**.

### Что такое npm?

**npm (Node Package Manager)** — это менеджер пакетов для JavaScript. Он идет в комплекте с Node.js.

- **Пакет (Package):** Это готовый кусок кода (библиотека или фреймворк), который можно легко установить и использовать в своем проекте. Например, React — это пакет.
- **Менеджер пакетов:** Это инструмент, который автоматизирует установку, обновление и управление этими пакетами.

С npm вам не нужно вручную скачивать файлы библиотек. Вы просто говорите, что вам нужно, и npm делает все за вас.

### Файл package.json

Каждый проект, использующий npm, имеет файл \`package.json\`. Это "паспорт" проекта. Он содержит:
- Название и версию проекта.
- **Список зависимостей (dependencies):** Пакеты, необходимые для работы вашего приложения.
- Скрипты для запуска (например, \`"start": "node index.js"\`).

### Основные команды

- \`npm init -y\`: Создает файл \`package.json\` в текущей папке.
- \`npm install <имя-пакета>\`: Устанавливает пакет и добавляет его в зависимости. Например, \`npm install react\`.
- \`npm install\`: Устанавливает все зависимости, перечисленные в \`package.json\`.
        `,
    },
    {
        id: 'module-11',
        title: 'Модуль 11: Введение в React',
        content: `
### Что такое React?

**React** — это JavaScript-библиотека для создания пользовательских интерфейсов (UI). Его главная идея — **компонентный подход**.

### Почему React так популярен?

1.  **Компоненты:** Вы разбиваете сложный интерфейс на маленькие, независимые и переиспользуемые "кирпичики" — компоненты. Например, кнопка, поле ввода, карточка товара — всё это компоненты. Это делает код более организованным и легким для поддержки.
2.  **Декларативный подход:** Вы описываете, *как* должен выглядеть интерфейс в определенном состоянии, а React сам заботится о том, *как* его обновить. Вам не нужно вручную менять DOM, как мы делали в "чистом" JavaScript.
3.  **Виртуальный DOM:** React использует "виртуальную" копию DOM. Когда состояние меняется, React сначала обновляет эту легкую копию, сравнивает ее с реальным DOM и обновляет только те части, которые действительно изменились. Это делает обновления очень быстрыми и эффективными.
4.  **Огромная экосистема:** Существует огромное количество готовых библиотек и инструментов для React, которые решают практически любую задачу (роутинг, управление состоянием, анимации и т.д.).

### React — это библиотека, а не фреймворк

Фреймворк (как Angular) диктует строгую структуру приложения. React же является библиотекой и отвечает только за отображение UI. Вы сами выбираете, какие инструменты использовать для роутинга, управления состоянием и других задач, что дает большую гибкость.
        `,
    },
    {
        id: 'module-12',
        title: 'Модуль 12: Настройка проекта на React',
        content: `
### Сборщики и окружение

Современные React-приложения используют специальный синтаксис (JSX) и код, который не все браузеры понимают напрямую. Поэтому нам нужны инструменты сборки, которые преобразуют наш код в обычный HTML, CSS и JavaScript.

**Vite** — это современный и очень быстрый инструмент для создания и разработки веб-приложений. Он идеально подходит для начинающих.

### Создание нового React-приложения с помощью Vite

1.  **Убедитесь, что у вас установлен Node.js и npm.** (см. Модуль 10).
2.  Откройте терминал (командную строку) и выполните команду:
    \`\`\`bash
    npm create vite@latest
    \`\`\`
3.  Vite задаст вам несколько вопросов:
    - **Project name:** Введите имя вашего проекта (например, \`my-react-app\`).
    - **Select a framework:** Выберите \`React\` с помощью стрелок на клавиатуре.
    - **Select a variant:** Выберите \`TypeScript + SWC\`. TypeScript — это современный стандарт, который мы будем изучать.
4.  После этого Vite создаст папку с вашим проектом. Перейдите в нее и установите зависимости:
    \`\`\`bash
    cd my-react-app
    npm install
    \`\`\`
5.  Запустите сервер для разработки:
    \`\`\`bash
    npm run dev
    \`\`\`
6.  Откройте браузер и перейдите по адресу, который Vite покажет в терминале (обычно \`http://localhost:5173\`). Вы увидите стартовую страницу вашего React-приложения!

### Структура проекта

Vite создает простую и понятную структуру папок:
- \`src/\`: Здесь будет находиться весь ваш код.
- \`src/App.tsx\`: Главный компонент вашего приложения.
- \`src/main.tsx\`: Точка входа, где ваше приложение "монтируется" в HTML.
- \`index.html\`: Основной HTML-файл.
        `,
    },
    {
        id: 'module-13',
        title: 'Модуль 13: Что такое JSX?',
        content: `
### JSX: JavaScript + XML

**JSX (JavaScript XML)** — это синтаксическое расширение для JavaScript, которое позволяет писать HTML-подобный код прямо внутри JS-файлов.

**Без JSX (чистый React):**
\`\`\`javascript
React.createElement('h1', { className: 'greeting' }, 'Привет, мир!');
\`\`\`
Это громоздко и неудобно.

**С JSX:**
\`\`\`jsx
const element = <h1 className="greeting">Привет, мир!</h1>;
\`\`\`
Этот код выглядит почти как HTML, но на самом деле это JavaScript. Инструменты сборки (такие как Vite) преобразуют этот JSX-код в вызовы \`React.createElement()\` за кулисами.

### Ключевые правила JSX

1.  **Один корневой элемент:** Компонент может возвращать только один корневой элемент. Если вам нужно вернуть несколько элементов, оберните их в родительский тег (\`<div>\`) или в **фрагмент** (\`<>\` ... \`</>\`).
    \`\`\`jsx
    // Правильно
    return (
      <>
        <h1>Заголовок</h1>
        <p>Абзац</p>
      </>
    );
    \`\`\`

2.  **JavaScript-выражения в фигурных скобках:** Вы можете вставлять любые JavaScript-выражения внутри JSX, обернув их в \`{}\`.
    \`\`\`jsx
    const name = "Алиса";
    const element = <h1>Привет, {name}!</h1>; // Привет, Алиса!

    const element2 = <p>2 + 2 = {2 + 2}</p>; // 2 + 2 = 4
    \`\`\`

3.  **Атрибуты в camelCase:** Атрибуты HTML, состоящие из двух слов (например, \`onclick\`, \`class\`), в JSX пишутся в стиле camelCase.
    - \`class\` становится \`className\`.
    - \`onclick\` становится \`onClick\`.
    - \`for\` (в \`<label>\`) становится \`htmlFor\`.

4.  **Незакрывающиеся теги:** Теги, у которых нет закрывающей пары в HTML (например, \`<img>\`, \`<input>\`), в JSX должны быть самозакрывающимися (заканчиваться на \`/>\`).
    \`\`\`jsx
    <img src="path/to/image.jpg" />
    <input type="text" />
    \`\`\`
        `,
    },
    {
        id: 'module-14',
        title: 'Модуль 14: Компоненты - строительные блоки React',
        content: `
### Что такое компонент?

**Компонент** — это независимый, переиспользуемый "кирпичик" интерфейса. Это JavaScript-функция, которая возвращает JSX-разметку.

Компоненты позволяют разбить сложный UI на простые части. Например, страница может состоять из компонентов \`<Header>\`, \`<Sidebar>\`, \`<Content>\`, \`<Footer>\`.

### Создание функционального компонента

В современном React компоненты создаются как обычные JavaScript-функции.

**Правила именования:** Имена компонентов **всегда** должны начинаться с большой буквы. Это помогает React отличать их от обычных HTML-тегов.

\`\`\`tsx
// src/components/Greeting.tsx

import React from 'react';

// Это функциональный компонент
function Greeting() {
  return <h1>Привет от компонента!</h1>;
}

export default Greeting; // Экспортируем компонент, чтобы его можно было использовать в других файлах
\`\`\`

### Использование компонента

Чтобы использовать компонент, вы импортируете его и используете как обычный HTML-тег.

\`\`\`tsx
// src/App.tsx

import React from 'react';
import Greeting from './components/Greeting'; // Импортируем наш компонент

function App() {
  return (
    <div>
      <p>Это основной компонент App.</p>
      <Greeting /> {/* Используем компонент Greeting */}
      <Greeting /> {/* Можно использовать многократно */}
    </div>
  );
}

export default App;
\`\`\`

### Преимущества компонентов

- **Переиспользование (Reusability):** Один и тот же компонент можно использовать в разных частях приложения.
- **Изоляция (Isolation):** Каждый компонент имеет свою логику и разметку, что упрощает разработку и отладку.
- **Композиция (Composition):** Вы можете создавать сложные компоненты, собирая их из более простых.
        `,
    },
    {
        id: 'module-15',
        title: 'Модуль 15: Props - передача данных в компоненты',
        content: `
### Что такое "props"?

**Props** (сокращение от "properties" — свойства) — это способ передавать данные от родительского компонента к дочернему. Они работают так же, как атрибуты в HTML.

Props позволяют делать компоненты динамическими и переиспользуемыми. Например, вместо того чтобы создавать отдельный компонент для приветствия каждого пользователя, мы можем создать один компонент \`Greeting\` и передавать ему имя пользователя через props.

### Передача props

Props передаются как атрибуты при вызове компонента.

\`\`\`tsx
// В родительском компоненте (например, App.tsx)
import UserProfile from './UserProfile';

function App() {
  return (
    <UserProfile name="Иван" age={30} />
  );
}
\`\`\`

### Получение props

В дочернем компоненте props приходят в виде одного объекта — первого аргумента функции.

С TypeScript мы также должны описать **тип** (форму) этого объекта.

\`\`\`tsx
// В дочернем компоненте (UserProfile.tsx)
import React from 'react';

// 1. Описываем "форму" наших props с помощью interface
interface UserProfileProps {
  name: string;
  age: number;
}

// 2. Указываем, что наш компонент принимает props этого типа
function UserProfile(props: UserProfileProps) {
  return (
    <div>
      <h2>Имя: {props.name}</h2>
      <p>Возраст: {props.age}</p>
    </div>
  );
}

// Альтернативный способ с деструктуризацией:
// function UserProfile({ name, age }: UserProfileProps) {
//   return (
//     <div>
//       <h2>Имя: {name}</h2>
//       <p>Возраст: {age}</p>
//     </div>
//   );
// }

export default UserProfile;
\`\`\`

### Props только для чтения

Важное правило React: **компонент никогда не должен изменять свои собственные props.** Props приходят "сверху" и являются неизменяемыми для дочернего компонента. Это обеспечивает предсказуемость потока данных.
        `,
    },
    {
        id: 'module-16',
        title: 'Модуль 16: State - управление состоянием компонента',
        content: `
### Что такое "state"?

Если **props** — это данные, которые компонент получает *извне*, то **state** (состояние) — это данные, которыми компонент управляет *внутри себя*.

Состояние — это то, что может меняться в результате взаимодействия с пользователем (клики, ввод текста) и вызывать **перерисовку (ре-рендер)** компонента.

### Хук useState

Для добавления состояния в функциональные компоненты используется **хук** \`useState\`.

- **Хук (Hook):** Специальная функция в React (начинается с \`use\`), которая позволяет "подцепиться" к возможностям React, таким как состояние и жизненный цикл.

\`useState\` возвращает массив из двух элементов:
1.  **Текущее значение состояния.**
2.  **Функция для обновления этого состояния.**

\`\`\`tsx
import React, { useState } from 'react'; // Не забудьте импортировать useState

function Counter() {
  // 1. Объявляем переменную состояния 'count'
  //    и функцию для ее обновления 'setCount'.
  //    В скобках useState(0) мы передаем начальное значение.
  const [count, setCount] = useState(0);

  // Функция-обработчик клика
  const increment = () => {
    // 2. Вызываем функцию обновления, чтобы изменить состояние
    setCount(count + 1);
  };

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={increment}>
        Нажми меня
      </button>
    </div>
  );
}
\`\`\`

### Как работает обновление?

1.  Изначально \`count\` равен \`0\`. Компонент рендерит \`<p>Вы нажали 0 раз</p>\`.
2.  Когда вы нажимаете кнопку, вызывается функция \`increment\`.
3.  Внутри нее вызывается \`setCount(count + 1)\`.
4.  React видит, что состояние изменилось.
5.  React **перерисовывает (ре-рендерит)** компонент \`Counter\` с новым значением \`count\`, которое теперь равно \`1\`.
6.  На экране появляется \`<p>Вы нажали 1 раз</p>\`.

**Важно:** Никогда не изменяйте состояние напрямую (\`count = count + 1\`). Всегда используйте функцию обновления (\`setCount\`), чтобы React знал о изменениях.
        `,
    },
    {
        id: 'module-17',
        title: 'Модуль 17: Условный рендеринг',
        content: `
### Что такое условный рендеринг?

Условный рендеринг — это отображение разного JSX в зависимости от определенного условия (например, от состояния или props). Это позволяет создавать динамические интерфейсы.

### 1. Оператор if

Вы можете использовать обычный \`if\` для определения, какой JSX вернуть.

\`\`\`tsx
function Greeting({ isLoggedIn }: { isLoggedIn: boolean }) {
  if (isLoggedIn) {
    return <h1>С возвращением!</h1>;
  }
  return <h1>Пожалуйста, войдите.</h1>;
}
\`\`\`

### 2. Тернарный оператор

Тернарный оператор (\`условие ? значение_если_true : значение_если_false\`) — это компактный способ для условного рендеринга прямо внутри JSX.

\`\`\`tsx
function LoginStatus() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  return (
    <div>
      {isLoggedIn ? (
        <p>Вы вошли в систему.</p>
      ) : (
        <p>Вы гость.</p>
      )}
      <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
        {isLoggedIn ? 'Выйти' : 'Войти'}
      </button>
    </div>
  );
}
\`\`\`

### 3. Логический оператор 'И' (&&)

Если вам нужно отрендерить что-то только при выполнении условия (а в противном случае ничего не рендерить), удобно использовать оператор \`&&\`.

\`\`\`tsx
function Mailbox({ unreadMessages }: { unreadMessages: string[] }) {
  return (
    <div>
      <h1>Здравствуйте!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          У вас {unreadMessages.length} непрочитанных сообщений.
        </h2>
      }
    </div>
  );
}
\`\`\`
Этот код работает, потому что в JavaScript \`true && выражение\` всегда вычисляется как \`выражение\`, а \`false && выражение\` — как \`false\`. React не рендерит \`false\`.

### 4. Не рендерить ничего

Если вы хотите, чтобы компонент ничего не отрендерил, верните из него \`null\`.

\`\`\`tsx
function WarningBanner({ showWarning }: { showWarning: boolean }) {
  if (!showWarning) {
    return null;
  }
  return <div className="warning">Предупреждение!</div>;
}
\`\`\`
        `,
    },
    {
        id: 'module-18',
        title: 'Модуль 18: Списки и ключи',
        content: `
### Рендеринг списков

Часто нам нужно отобразить список элементов на основе массива данных. В React это делается с помощью метода массива \`.map()\`.

Метод \`.map()\` проходит по каждому элементу массива, выполняет для него функцию и возвращает новый массив с результатами.

\`\`\`tsx
const numbers = [1, 2, 3, 4, 5];

const listItems = numbers.map((number) =>
  <li>{number}</li>
);

// Затем мы можем вставить его в JSX
// <ul>{listItems}</ul>
\`\`\`

Обычно это делается прямо в JSX:

\`\`\`tsx
function NumberList({ numbers }: { numbers: number[] }) {
  return (
    <ul>
      {numbers.map((number) =>
        <li>{number}</li>
      )}
    </ul>
  );
}
\`\`\`

### Зачем нужны ключи (keys)?

Когда вы запускаете приведенный выше код, React покажет в консоли предупреждение: "Each child in a list should have a unique 'key' prop." (Каждый дочерний элемент в списке должен иметь уникальный 'key' prop).

**Ключ (key)** — это специальный строковый атрибут, который вы должны добавить к элементам списка.

\`\`\`tsx
function NumberList({ numbers }: { numbers: number[] }) {
  return (
    <ul>
      {numbers.map((number) =>
        <li key={number.toString()}> {/* Добавляем ключ */}
          {number}
        </li>
      )}
    </ul>
  );
}
\`\`\`

### Почему ключи важны?

Ключи помогают React идентифицировать, какие элементы были изменены, добавлены или удалены. Когда список обновляется, React использует ключи, чтобы сопоставить элементы старого и нового списков и эффективно обновить DOM.

**Правила для ключей:**
1.  **Ключи должны быть уникальными** среди "соседних" элементов (внутри одного списка).
2.  Лучший ключ — это **уникальный ID** из ваших данных (например, ID поста из базы данных).
3.  **Не используйте индекс массива в качестве ключа,** если порядок элементов может меняться. Это может привести к проблемам с производительностью и состоянием компонентов.
        `,
    },
    {
        id: 'module-19',
        title: 'Модуль 19: Обработка событий',
        content: `
### Как обрабатывать события в React?

Обработка событий в React очень похожа на обработку событий в DOM, но есть несколько синтаксических отличий:

1.  **Именование:** События в React именуются в стиле camelCase. Например, \`onclick\` в HTML становится \`onClick\` в React.
2.  **Передача функции:** В качестве обработчика события вы передаете функцию, а не строку.

**HTML:**
\`\`\`html
<button onclick="showAlert()">Нажми</button>
\`\`\`

**React:**
\`\`\`tsx
<button onClick={showAlert}>Нажми</button>
\`\`\`

### Пример: Компонент-переключатель

\`\`\`tsx
import React, { useState } from 'react';

function Toggle() {
  const [isToggleOn, setIsToggleOn] = useState(true);

  // Мы определяем метод handleClick
  function handleClick() {
    // Используем функцию обновления, чтобы передать новое состояние
    setIsToggleOn(!isToggleOn);
  }

  return (
    <button onClick={handleClick}>
      {isToggleOn ? 'Включено' : 'Выключено'}
    </button>
  );
}
\`\`\`

### Передача аргументов в обработчики

Часто нужно передать дополнительный аргумент в обработчик. Например, ID элемента, который нужно удалить.

**Неправильно:**
\`\`\`tsx
// Этот код вызовет deleteItem СРАЗУ при рендере, а не по клику!
<button onClick={deleteItem(id)}>Удалить</button>
\`\`\`

**Правильно (используя стрелочную функцию):**
\`\`\`tsx
// Мы передаем в onClick функцию, которая, в свою очередь, вызовет deleteItem с нужным id
<button onClick={() => deleteItem(id)}>Удалить</button>
\`\`\`

### Объект события (Event Object)

React передает в обработчик синтетический объект события, который является кросс-браузерной оберткой над нативным событием.

Вы можете предотвратить стандартное поведение браузера (например, перезагрузку страницы при отправке формы) с помощью \`e.preventDefault()\`.

\`\`\`tsx
function Form() {
  function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    console.log('Вы нажали "Отправить".');
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Отправить</button>
    </form>
  );
}
\`\`\`
        `,
    },
    {
        id: 'module-20',
        title: 'Модуль 20: Жизненный цикл и хук useEffect',
        content: `
### Что такое "сайд-эффекты"?

В React компоненты должны быть "чистыми": с одинаковыми props они всегда возвращают одинаковый JSX. Однако, часто компонентам нужно взаимодействовать с "внешним миром". Такие взаимодействия называются **сайд-эффектами (side effects)**.

Примеры сайд-эффектов:
- Запросы к API для получения данных.
- Подписка на события (например, WebSocket).
- Прямое манипулирование DOM.
- Установка таймеров (\`setTimeout\`, \`setInterval\`).

### Хук useEffect

Хук \`useEffect\` позволяет выполнять сайд-эффекты в функциональных компонентах. Он принимает два аргумента:

1.  **Функция-эффект:** Код, который нужно выполнить.
2.  **Массив зависимостей (опционально):** Массив переменных. Эффект будет перезапускаться только если одна из этих переменных изменится.

### Как работает useEffect

**1. Эффект выполняется после каждого рендера:**
Если вы не передадите массив зависимостей, эффект будет запускаться после *каждого* рендера компонента.

\`\`\`tsx
useEffect(() => {
  document.title = \`Вы нажали \${count} раз\`;
}); // Нет массива зависимостей
\`\`\`

**2. Эффект выполняется только один раз (при монтировании):**
Если вы передадите пустой массив зависимостей (\`[]\`), эффект выполнится только один раз, когда компонент впервые появится на экране. Это идеально подходит для загрузки данных.

\`\`\`tsx
useEffect(() => {
  // Загружаем данные с сервера
}, []); // Пустой массив
\`\`\`

**3. Эффект выполняется при изменении зависимости:**
Если вы передадите переменные в массив, эффект запустится при монтировании, а затем будет перезапускаться каждый раз, когда значение одной из этих переменных изменится.

\`\`\`tsx
useEffect(() => {
  document.title = \`Вы нажали \${count} раз\`;
}, [count]); // Зависимость - count
\`\`\`

### Очистка эффекта

Некоторые эффекты требуют "очистки" (например, отписка от событий, отмена таймера). Для этого нужно вернуть функцию из вашего эффекта. Эта функция будет вызвана, когда компонент удаляется с экрана, или перед следующим запуском эффекта.

\`\`\`tsx
useEffect(() => {
  const timerId = setInterval(() => {
    console.log('Тик');
  }, 1000);

  // Функция очистки
  return () => {
    clearInterval(timerId);
  };
}, []);
\`\`\`
        `,
    },
    {
        id: 'module-21',
        title: 'Модуль 21: Работа с формами в React',
        content: `
### Контролируемые компоненты

В HTML элементы форм, такие как \`<input>\`, \`<textarea>\` и \`<select>\`, обычно сами управляют своим состоянием. В React принято использовать подход, называемый **"контролируемые компоненты"**.

Это означает, что состояние формы хранится в state-переменной React-компонента. Любое изменение в поле ввода обновляет state, а значение в поле ввода всегда отражает значение из state.

Таким образом, React-компонент становится "единственным источником правды" для формы.

### Пример: простое текстовое поле

\`\`\`tsx
import React, { useState } from 'react';

function NameForm() {
  // 1. Создаем state для хранения значения инпута
  const [value, setValue] = useState('');

  // 2. Обработчик, который обновляет state при каждом изменении
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setValue(event.target.value);
  };

  const handleSubmit = (event: React.FormEvent) => {
    alert('Отправленное имя: ' + value);
    event.preventDefault();
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Имя:
        {/* 3. Связываем инпут с состоянием: */}
        {/*    - value берется из state */}
        {/*    - onChange обновляет state */}
        <input type="text" value={value} onChange={handleChange} />
      </label>
      <input type="submit" value="Отправить" />
    </form>
  );
}
\`\`\`

### Работа с несколькими полями

Если у вас несколько полей ввода, вы можете использовать один обработчик. Для этого нужно добавить атрибут \`name\` к каждому элементу и использовать его для определения, какое поле обновить.

\`\`\`tsx
const [formState, setFormState] = useState({
  username: '',
  password: ''
});

const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = event.target;
  setFormState(prevState => ({
    ...prevState,
    [name]: value
  }));
};

// ... в JSX
<input name="username" value={formState.username} onChange={handleInputChange} />
<input name="password" value={formState.password} onChange={handleInputChange} />
\`\`\`
        `,
    },
    {
        id: 'module-22',
        title: 'Модуль 22: Стилизация компонентов',
        content: `
### Способы стилизации React-компонентов

Существует множество подходов к стилизации. Рассмотрим самые популярные.

#### 1. Обычный CSS с классами

Это самый простой способ, который мы уже использовали. Вы создаете \`.css\` файл и импортируете его в ваш компонент.

\`\`\`css
/* UserProfile.css */
.card {
  border: 1px solid #ccc;
  padding: 16px;
  border-radius: 8px;
}
.card-title {
  font-size: 1.5rem;
}
\`\`\`
\`\`\`tsx
// UserProfile.tsx
import React from 'react';
import './UserProfile.css';

function UserProfile() {
  return (
    <div className="card">
      <h2 className="card-title">Профиль</h2>
    </div>
  );
}
\`\`\`
**Проблема:** Имена классов глобальны. Если в другой части приложения будет класс \`.card\`, стили могут конфликтовать.

#### 2. CSS Modules

**CSS Modules** решают проблему глобальных имен. Это обычный CSS-файл, но при сборке проекта все классы в нем становятся уникальными.

Переименуйте файл в \`UserProfile.module.css\`.

\`\`\`tsx
// UserProfile.tsx
import React from 'react';
import styles from './UserProfile.module.css'; // Импортируем стили как объект

function UserProfile() {
  return (
    // Используем классы из объекта 'styles'
    <div className={styles.card}>
      <h2 className={styles.cardTitle}>Профиль</h2>
    </div>
  );
}
\`\`\`
При сборке \`styles.card\` превратится в что-то вроде \`UserProfile_card__a1b2c\`, что гарантирует уникальность.

#### 3. CSS-in-JS (Styled Components)

Этот подход позволяет писать CSS прямо в JavaScript-файлах с помощью специальных библиотек, таких как **Styled Components** или **Emotion**. Наша библиотека **ZwheUI** использует похожий собственный механизм.

\`\`\`tsx
import React from 'react';
import styled from 'styled-components';

// Создаем React-компонент <Title> со стилями
const Title = styled.h1\`
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
\`;

// Создаем компонент <Wrapper>
const Wrapper = styled.section\`
  padding: 4em;
  background: papayawhip;
\`;

function MyStyledComponent() {
  return (
    <Wrapper>
      <Title>Привет, мир!</Title>
    </Wrapper>
  );
}
\`\`\`
**Преимущества:** Стили инкапсулированы внутри компонента, и вы можете легко передавать props для динамического изменения стилей.
        `,
    },
    {
        id: 'module-23',
        title: 'Модуль 23: Декомпозиция компонентов',
        content: `
### Что такое декомпозиция?

Декомпозиция — это процесс разбиения больших, сложных компонентов на более мелкие, простые и переиспользуемые. Это один из ключевых принципов React, который помогает поддерживать чистоту и читаемость кода.

### Когда нужно декомпозировать?

Признаки того, что компонент пора разделить:
- Он стал слишком большим (сотни строк кода).
- Он выполняет слишком много разных задач.
- Часть его логики или разметки повторяется в других местах.
- Он содержит много вложенных и сложных состояний.

### Пример: От монолита к компонентам

**До декомпозиции (один большой компонент):**

\`\`\`tsx
function App() {
  const user = { name: 'Алиса', avatarUrl: '...' };
  const comments = [{ id: 1, text: '...' }, { id: 2, text: '...' }];

  return (
    <div className="page">
      <header>
        <img src={user.avatarUrl} alt={user.name} />
        <h1>{user.name}</h1>
      </header>
      <main>
        <h2>Комментарии</h2>
        <ul>
          {comments.map(comment => (
            <li key={comment.id}>
              <p>{comment.text}</p>
            </li>
          ))}
        </ul>
      </main>
    </div>
  );
}
\`\`\`

**После декомпозиции (несколько маленьких компонентов):**

1.  **Компонент \`Avatar\`:**
    \`\`\`tsx
    function Avatar({ user }) {
      return <img src={user.avatarUrl} alt={user.name} />;
    }
    \`\`\`

2.  **Компонент \`Comment\`:**
    \`\`\`tsx
    function Comment({ comment }) {
      return <li><p>{comment.text}</p></li>;
    }
    \`\`\`

3.  **Компонент \`CommentList\`:**
    \`\`\`tsx
    function CommentList({ comments }) {
      return (
        <ul>
          {comments.map(comment => <Comment key={comment.id} comment={comment} />)}
        </ul>
      );
    }
    \`\`\`

4.  **Обновленный \`App\`:**
    \`\`\`tsx
    function App() {
      const user = { name: 'Алиса', avatarUrl: '...' };
      const comments = [{ id: 1, text: '...' }, { id: 2, text: '...' }];

      return (
        <div className="page">
          <header>
            <Avatar user={user} />
            <h1>{user.name}</h1>
          </header>
          <main>
            <h2>Комментарии</h2>
            <CommentList comments={comments} />
          </main>
        </div>
      );
    }
    \`\`\`

Теперь каждый компонент отвечает за свою маленькую часть, его легче читать, тестировать и переиспользовать.
        `,
    },
    {
        id: 'module-24',
        title: 'Модуль 24: Поднятие состояния (Lifting State Up)',
        content: `
### Проблема: Синхронизация состояния

Представьте, у вас есть два дочерних компонента, состояние которых должно быть синхронизировано. Например, калькулятор температуры, где изменение градусов в Цельсиях должно тут же отражаться в Фаренгейтах, и наоборот.

Каждый компонент не может управлять состоянием другого напрямую. Как их синхронизировать?

### Решение: Поднятие состояния

Принцип **"поднятия состояния"** гласит: если нескольким компонентам нужно общее состояние, это состояние следует переместить в их ближайшего общего родителя.

Затем родитель передает это состояние дочерним компонентам через **props**, а также передает **функции для обновления** этого состояния.

### Пример: Калькулятор температуры

**1. Дочерний компонент \`TemperatureInput\`:**
Этот компонент ничего не знает о логике. Он просто отображает значение и вызывает функцию \`onTemperatureChange\` при вводе.

\`\`\`tsx
function TemperatureInput(props) {
  return (
    <fieldset>
      <legend>Введите температуру в {props.scale}:</legend>
      <input
        value={props.temperature}
        onChange={(e) => props.onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}
\`\`\`

**2. Родительский компонент \`Calculator\`:**
Здесь хранится всё состояние и логика конвертации.

\`\`\`tsx
function Calculator() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c');

  // Функции для конвертации
  const toCelsius = (f) => (f - 32) * 5 / 9;
  const toFahrenheit = (c) => (c * 9 / 5) + 32;

  // Определяем значения для обоих инпутов
  const celsius = scale === 'f' ? toCelsius(temperature) : temperature;
  const fahrenheit = scale === 'c' ? toFahrenheit(temperature) : temperature;

  return (
    <div>
      <TemperatureInput
        scale="Цельсиях"
        temperature={celsius}
        onTemperatureChange={(t) => {
          setScale('c');
          setTemperature(t);
        }}
      />
      <TemperatureInput
        scale="Фаренгейтах"
        temperature={fahrenheit}
        onTemperatureChange={(t) => {
          setScale('f');
          setTemperature(t);
        }}
      />
    </div>
  );
}
\`\`\`

Теперь состояние (\`temperature\` и \`scale\`) находится в родительском компоненте \`Calculator\`. Оба \`TemperatureInput\` получают данные через props и сообщают родителю об изменениях, вызывая колбэки. Данные текут "сверху вниз", что делает приложение предсказуемым.
        `,
    },
    {
        id: 'module-25',
        title: 'Модуль 25: Введение в TypeScript с React',
        content: `
### Что такое TypeScript?

**TypeScript (TS)** — это надмножество JavaScript. Это означает, что любой валидный JS-код является и валидным TS-кодом. TypeScript добавляет к JavaScript одну важную вещь: **статическую типизацию**.

### Зачем нужна типизация?

В обычном JavaScript переменная может менять свой тип:
\`\`\`javascript
let myVar = "привет"; // сейчас строка
myVar = 5; // а теперь число. Это может вызвать ошибку где-то дальше.
\`\`\`
TypeScript позволяет нам заранее определить, какой тип данных должна содержать переменная. Если мы попытаемся присвоить ей значение другого типа, мы получим **ошибку на этапе компиляции**, а не во время выполнения программы, когда ее уже увидит пользователь.

\`\`\`typescript
let myVar: string = "привет";
// myVar = 5; // Ошибка! Type 'number' is not assignable to type 'string'.
\`\`\`

### Преимущества TypeScript с React

1.  **Меньше ошибок:** Вы ловите ошибки, связанные с типами, еще до запуска приложения.
2.  **Улучшенная автодокументация:** Типы делают код более читаемым и понятным. Вы сразу видите, какие props ожидает компонент и что возвращает функция.
3.  **Отличная поддержка в редакторах:** VS Code и другие редакторы предоставляют мощное автодополнение и подсказки на основе типов.

### Типизация Props компонента

Самое частое применение TS в React — это описание props. Мы делаем это с помощью \`interface\`.

\`\`\`tsx
import React from 'react';

// 1. Описываем интерфейс для props
interface GreetingProps {
  name: string;
  messageCount: number;
  isLoggedIn: boolean;
}

// 2. Указываем, что наш компонент является функциональным компонентом React (React.FC)
//    и принимает props типа GreetingProps
const Greeting: React.FC<GreetingProps> = ({ name, messageCount, isLoggedIn }) => {
  if (!isLoggedIn) {
    return <p>Пожалуйста, войдите.</p>;
  }

  return (
    <div>
      <h1>Привет, {name}!</h1>
      <p>У вас {messageCount} новых сообщений.</p>
    </div>
  );
};
\`\`\`
Теперь, если вы попытаетесь использовать компонент \`<Greeting>\` без обязательного prop \`name\` или передадите в \`messageCount\` строку вместо числа, TypeScript немедленно сообщит об ошибке.
        `,
    },
    {
        id: 'module-26',
        title: 'Модуль 26: Хук useContext - глобальное состояние',
        content: `
### Проблема "пробрасывания" props (Props Drilling)

Представьте, что у вас есть глубоко вложенный компонент, которому нужны данные из самого верхнего компонента (например, информация о текущем пользователе или теме). Чтобы передать эти данные, вам придется "пробрасывать" их через все промежуточные компоненты, даже если они им не нужны. Это делает код грязным и сложным для поддержки.

### Решение: Context API

**Context API** — это механизм в React, который позволяет передавать данные через дерево компонентов, не передавая их явно через props на каждом уровне.

Он состоит из трех частей:
1.  **\`createContext\`:** Создает объект контекста.
2.  **Provider (Поставщик):** Компонент, который "поставляет" значение в контекст. Все его дочерние компоненты (любой глубины) смогут получить доступ к этому значению.
3.  **\`useContext\` (Потребитель):** Хук, который позволяет компоненту "подписаться" на изменения контекста и получить его значение.

### Пример: Переключение темы (светлая/темная)

**1. Создаем контекст (\`ThemeContext.ts\`):**
\`\`\`ts
import { createContext } from 'react';

// Описываем, какие данные будут в нашем контексте
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

// Создаем контекст с начальным значением
export const ThemeContext = createContext<ThemeContextType>({
  theme: 'light',
  toggleTheme: () => {},
});
\`\`\`

**2. Создаем Provider (\`ThemeProvider.tsx\`):**
\`\`\`tsx
import React, { useState } from 'react';
import { ThemeContext } from './ThemeContext';

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    // "Оборачиваем" дочерние компоненты в Provider и передаем ему актуальное значение
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};
\`\`\`

**3. Оборачиваем приложение в Provider (\`App.tsx\`):**
\`\`\`tsx
import { ThemeProvider } from './ThemeProvider';
import MyPage from './MyPage';

function App() {
  return (
    <ThemeProvider>
      <MyPage />
    </ThemeProvider>
  );
}
\`\`\`

**4. Используем контекст в любом дочернем компоненте (\`MyPage.tsx\`):**
\`\`\`tsx
import React, { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function MyPage() {
  // Получаем значение из контекста с помощью хука useContext
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
      <p>Текущая тема: {theme}</p>
      <button onClick={toggleTheme}>Переключить тему</button>
    </div>
  );
}
\`\`\`
Теперь любой компонент внутри \`ThemeProvider\` может получить доступ к теме, не получая ее через props.
        `,
    },
    {
        id: 'module-27',
        title: 'Модуль 27: Хук useRef - доступ к DOM и хранение значений',
        content: `
### Что такое useRef?

Хук \`useRef\` — это многофункциональный инструмент в React. Он может использоваться для двух основных целей:

1.  **Получение прямого доступа к DOM-элементам.**
2.  **Хранение изменяемых значений, которые *не* вызывают перерисовку компонента при их изменении.**

### 1. Доступ к DOM-элементам

Иногда нам нужно напрямую взаимодействовать с HTML-элементом, минуя декларативный подход React. Например, чтобы сфокусироваться на поле ввода, запустить проигрывание видео или измерить размеры элемента.

**Как это работает:**
1.  Создаем "реф" с помощью \`useRef(null)\`.
2.  Привязываем этот реф к DOM-элементу через атрибут \`ref\`.
3.  После рендера компонента, React поместит ссылку на реальный DOM-элемент в свойство \`ref.current\`.

**Пример: Фокус на поле ввода при загрузке страницы.**

\`\`\`tsx
import React, { useRef, useEffect } from 'react';

function TextInputWithFocusButton() {
  // 1. Создаем реф
  const inputRef = useRef<HTMLInputElement>(null);

  // useEffect выполнится после того, как компонент будет отрендерен
  useEffect(() => {
    // 3. Вызываем метод focus() на DOM-элементе
    inputRef.current?.focus();
  }, []); // Пустой массив зависимостей, чтобы это произошло только один раз

  return (
    <>
      {/* 2. Привязываем реф к инпуту */}
      <input ref={inputRef} type="text" />
    </>
  );
}
\`\`\`

### 2. Хранение изменяемых значений

Представьте, что вам нужно хранить какое-то значение между рендерами (например, ID таймера), но его изменение не должно вызывать перерисовку компонента.

- Если использовать \`useState\`, компонент будет перерисовываться при каждом изменении.
- Если использовать обычную переменную (\`let\`), ее значение будет сбрасываться при каждом рендере.

\`useRef\` решает эту проблему. Значение, хранящееся в \`.current\`, сохраняется между рендерами.

**Пример: Таймер, который можно остановить.**

\`\`\`tsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  // Используем ref для хранения ID таймера
  const intervalRef = useRef<number | null>(null);

  const handleStart = () => {
    intervalRef.current = window.setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
  };

  const handleStop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
  };

  return (
    <div>
      <p>Таймер: {seconds} сек.</p>
      <button onClick={handleStart}>Старт</button>
      <button onClick={handleStop}>Стоп</button>
    </div>
  );
}
\`\`\`
Изменение \`intervalRef.current\` не вызывает ре-рендер, что является правильным поведением в данном случае.
        `,
    },
    {
        id: 'module-28',
        title: 'Модуль 28: Оптимизация производительности: useMemo, useCallback, React.memo',
        content: `
### Проблема ненужных перерисовок (ре-рендеров)

React очень быстр, но иногда мы можем создавать компоненты, которые перерисовываются слишком часто без необходимости. Это может замедлить приложение, особенно если компонент выполняет "тяжелые" вычисления или рендерит много элементов.

Ненужный ре-рендер дочернего компонента происходит, когда его родитель перерисовывается, даже если props, переданные дочернему компоненту, не изменились.

### Инструменты для оптимизации

React предоставляет несколько хуков для **мемоизации** — техники кеширования, которая помогает избежать повторных вычислений или ре-рендеров.

#### 1. React.memo

\`React.memo\` — это **компонент высшего порядка (HOC)**, который "заворачивает" ваш компонент. React будет кешировать результат рендера этого компонента и пропускать следующий ре-рендер, если его **props не изменились**.

\`\`\`tsx
const MyComponent = React.memo(function MyComponent(props) {
  /* рендеринг компонента */
});
\`\`\`
Теперь \`MyComponent\` будет перерисовываться только тогда, когда изменятся его \`props\`.

#### 2. useCallback

Проблема с \`React.memo\` в том, что если вы передаете в него функцию (например, обработчик клика), она будет создаваться заново при каждом рендере родителя. Для \`React.memo\` это будет новая функция, и он перерисует дочерний компонент.

Хук \`useCallback\` мемоизирует (кеширует) саму функцию. Он возвращает одну и ту же ссылку на функцию между рендерами, пока не изменятся ее зависимости.

\`\`\`tsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b], // Зависимости
);
\`\`\`
Теперь можно безопасно передавать \`memoizedCallback\` в мемоизированный дочерний компонент.

#### 3. useMemo

Хук \`useMemo\` похож на \`useCallback\`, но он мемоизирует **результат выполнения** функции (значение), а не саму функцию. Это полезно для "тяжелых" вычислений, которые не нужно повторять на каждом рендере.

\`\`\`tsx
// Этот сложный расчет будет выполнен только при первом рендере
// или когда изменится 'items'
const visibleItems = useMemo(
  () => computeVisibleItems(items, filter),
  [items, filter] // Зависимости
);
\`\`\`

**Важно:** Не используйте эти хуки повсеместно. Преждевременная оптимизация может усложнить код. Применяйте их только там, где вы действительно столкнулись с проблемами производительности (используйте React DevTools Profiler для их поиска).
        `,
    },
    {
        id: 'module-29',
        title: 'Модуль 29: Создание кастомных хуков',
        content: `
### Что такое кастомный хук?

**Кастомный хук** — это JavaScript-функция, имя которой начинается с \`use\`, и которая может вызывать другие хуки (например, \`useState\`, \`useEffect\`).

Они позволяют вам выносить логику компонентов в переиспользуемые функции. Если вы замечаете, что копируете и вставляете одну и ту же логику в разные компоненты (например, работу с \`useEffect\` и \`useState\` для получения данных), значит, эту логику можно вынести в кастомный хук.

### Пример: Хук для отслеживания размеров окна

Давайте создадим хук \`useWindowSize\`, который будет возвращать текущую ширину и высоту окна браузера.

**1. Создаем файл хука (\`hooks/useWindowSize.ts\`):**
\`\`\`ts
import { useState, useEffect } from 'react';

// Описываем тип возвращаемого значения
interface WindowSize {
  width: number | undefined;
  height: number | undefined;
}

export function useWindowSize(): WindowSize {
  // 1. Создаем состояние для хранения размеров
  const [windowSize, setWindowSize] = useState<WindowSize>({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    // 2. Создаем обработчик, который обновляет состояние
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    // 3. Добавляем слушателя события 'resize'
    window.addEventListener("resize", handleResize);

    // Вызываем обработчик сразу, чтобы получить начальные размеры
    handleResize();

    // 4. Возвращаем функцию очистки, чтобы удалить слушателя
    return () => window.removeEventListener("resize", handleResize);
  }, []); // Пустой массив, чтобы эффект выполнился только один раз

  // 5. Возвращаем текущие размеры
  return windowSize;
}
\`\`\`

**2. Используем кастомный хук в компоненте:**
\`\`\`tsx
import React from 'react';
import { useWindowSize } from './hooks/useWindowSize';

function MyComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>Ширина окна: {width}px</p>
      <p>Высота окна: {height}px</p>
    </div>
  );
}
\`\`\`

### Преимущества кастомных хуков

- **Переиспользование логики:** Вы можете использовать один и тот же хук в десятках компонентов.
- **Чистые компоненты:** Компоненты освобождаются от сложной логики и занимаются только отображением, что делает их более читаемыми.
- **Простота тестирования:** Вы можете тестировать логику хука отдельно от UI.
        `,
    },
    {
        id: 'module-30',
        title: 'Модуль 30: Введение в менеджеры состояний (Zustand)',
        content: `
### Проблема: Глобальное состояние

Когда приложение становится большим, \`Context API\` может быть недостаточно. При каждом изменении контекста все компоненты, которые его используют, перерисовываются. Если состояние меняется часто, это может повлиять на производительность.

**Менеджеры состояний (State Managers)** — это библиотеки, которые предоставляют более оптимизированный и структурированный способ управления глобальным состоянием.

Популярные менеджеры: Redux, MobX, **Zustand**, Recoil.

### Что такое Zustand?

**Zustand** — это очень маленький, быстрый и простой менеджер состояний для React. Его главное преимущество — минималистичный API и отсутствие необходимости оборачивать все приложение в \`<Provider>\`.

### Как работает Zustand?

Вы создаете **"хранилище" (store)** — это хук, который содержит ваше состояние и функции для его изменения.

**1. Создаем хранилище (\`store.ts\`):**
\`\`\`ts
import { create } from 'zustand';

// Описываем тип нашего состояния и действий
interface BearState {
  bears: number;
  increasePopulation: () => void;
  removeAllBears: () => void;
}

// Создаем хук-хранилище
export const useBearStore = create<BearState>((set) => ({
  bears: 0,
  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 }),
}));
\`\`\`

**2. Используем хранилище в компонентах:**

Любой компонент может импортировать этот хук и использовать его для доступа к состоянию и действиям.

\`\`\`tsx
// Компонент, который отображает количество медведей
function BearCounter() {
  // Получаем только нужную часть состояния.
  // Компонент будет перерисовываться только при изменении 'bears'.
  const bears = useBearStore((state) => state.bears);
  return <h1>{bears} around here ...</h1>;
}

// Компонент с кнопками для управления
function Controls() {
  const increasePopulation = useBearStore((state) => state.increasePopulation);
  return <button onClick={increasePopulation}>one up</button>;
}
\`\`\`

### Преимущества Zustand

- **Простота:** Очень легко настроить и использовать.
- **Производительность:** Компоненты подписываются только на те части состояния, которые им нужны, что предотвращает лишние ре-рендеры.
- **Нет Provider:** Не нужно оборачивать приложение в провайдеры.
        `,
    },
    {
        id: 'module-31',
        title: 'Модуль 31: Роутинг с React Router',
        content: `
### Что такое роутинг?

Большинство веб-приложений состоят из нескольких страниц (например, главная, о нас, контакты). В традиционных сайтах каждый переход на новую страницу означает полную перезагрузку из сервера.

В **одностраничных приложениях (Single-Page Applications, SPA)**, таких как React-приложения, вся "смена страниц" происходит на стороне клиента без перезагрузки. **Роутинг** — это процесс управления тем, какой компонент-страницу показывать в зависимости от URL в адресной строке.

**React Router** — это стандартная библиотека для роутинга в React.

### Установка

\`\`\`bash
npm install react-router-dom
\`\`\`

### Основные компоненты

1.  **\`BrowserRouter\`:** Компонент, который нужно обернуть вокруг всего вашего приложения. Он использует History API браузера для синхронизации UI с URL.
2.  **\`Routes\`:** Контейнер для всех ваших маршрутов.
3.  **\`Route\`:** Определяет один маршрут. Он связывает URL-путь (\`path\`) с конкретным компонентом (\`element\`).
4.  **\`Link\`:** Компонент для создания навигационных ссылок. Он похож на тег \`<a>\`, но предотвращает перезагрузку страницы.

### Пример настройки

**1. Оборачиваем приложение в \`BrowserRouter\` (\`main.tsx\`):**
\`\`\`tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
\`\`\`

**2. Определяем маршруты и навигацию (\`App.tsx\`):**
\`\`\`tsx
import React from 'react';
import { Routes, Route, Link } from 'react-router-dom';

// Создаем компоненты-страницы
const HomePage = () => <h2>Главная страница</h2>;
const AboutPage = () => <h2>О нас</h2>;
const NotFoundPage = () => <h2>Страница не найдена</h2>;

function App() {
  return (
    <div>
      <nav>
        <ul>
          <li>
            <Link to="/">Главная</Link>
          </li>
          <li>
            <Link to="/about">О нас</Link>
          </li>
        </ul>
      </nav>

      <hr />

      {/* Здесь будут рендериться компоненты в зависимости от URL */}
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        {/* Маршрут "*" сработает, если ни один из верхних не подошел */}
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </div>
  );
}
\`\`\`
Теперь при переходе по ссылкам "Главная" и "О нас" URL в браузере будет меняться, и React Router будет отображать соответствующий компонент без перезагрузки страницы.
        `,
    },
    {
        id: 'module-32',
        title: 'Модуль 32: Динамический роутинг',
        content: `
### Что такое динамический роутинг?

Часто нам нужны страницы, URL которых зависит от данных. Например, страница профиля пользователя (\`/users/1\`, \`/users/2\`) или страница конкретного поста в блоге (\`/posts/my-first-post\`).

Создавать отдельный \`Route\` для каждого пользователя или поста невозможно. **Динамический роутинг** позволяет нам создать один "шаблон" маршрута, который будет соответствовать множеству URL.

### Параметры маршрута (Route Parameters)

В React Router мы можем указать динамическую часть URL с помощью двоеточия \`:\`.

\`\`\`tsx
<Route path="/users/:userId" element={<UserProfile />} />
\`\`\`
Этот маршрут будет соответствовать \`/users/1\`, \`/users/jane\`, \`/users/любое-значение\`. Часть URL после \`/users/\` будет доступна в компоненте как **параметр** \`userId\`.

### Хук useParams

Чтобы получить доступ к параметрам маршрута внутри компонента, используется хук \`useParams\`. Он возвращает объект, где ключи — это имена параметров из \`path\`.

**Пример: Страница профиля пользователя**

\`\`\`tsx
import React from 'react';
import { useParams } from 'react-router-dom';

// Предположим, у нас есть какие-то данные о пользователях
const usersData = {
  '1': { name: 'Иван', email: 'ivan@example.com' },
  '2': { name: 'Мария', email: 'maria@example.com' }
};

function UserProfile() {
  // 1. Получаем параметры из URL
  const params = useParams();
  const userId = params.userId;

  // 2. Находим пользователя по ID
  const user = usersData[userId];

  // 3. Если пользователь не найден, показываем сообщение
  if (!user) {
    return <h2>Пользователь не найден.</h2>;
  }

  return (
    <div>
      <h1>Профиль пользователя</h1>
      <p>ID: {userId}</p>
      <p>Имя: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

// В App.tsx нужно добавить ссылки и маршрут:
// <Link to="/users/1">Пользователь 1</Link>
// <Link to="/users/2">Пользователь 2</Link>
// <Route path="/users/:userId" element={<UserProfile />} />
\`\`\`
Теперь, когда вы перейдете по URL \`/users/1\`, компонент \`UserProfile\` отрендерит данные для Ивана.
        `,
    },
    {
        id: 'module-33',
        title: 'Модуль 33: Вложенные маршруты (Nested Routes)',
        content: `
### Что такое вложенные маршруты?

Вложенные маршруты — это мощная функция React Router, которая позволяет связывать структуру URL со структурой вложенных компонентов.

Это идеально подходит для создания макетов страниц, где одна часть остается постоянной (например, боковая панель), а другая меняется.

### Компонент Outlet

Ключевым элементом вложенного роутинга является компонент \`<Outlet />\`. Он работает как **плейсхолдер** в родительском маршруте, указывая, где должны рендериться дочерние маршруты.

### Пример: Панель управления (Dashboard)

Представим панель управления с общей навигацией и меняющимся контентом.

Структура URL:
- \`/dashboard\`: Показывает приветствие.
- \`/dashboard/profile\`: Показывает профиль.
- \`/dashboard/settings\`: Показывает настройки.

**1. Создаем родительский компонент-макет (\`DashboardLayout.tsx\`):**
\`\`\`tsx
import React from 'react';
import { Link, Outlet } from 'react-router-dom';

function DashboardLayout() {
  return (
    <div>
      <h1>Панель управления</h1>
      <nav>
        <Link to="/dashboard">Главная</Link> |{' '}
        <Link to="/dashboard/profile">Профиль</Link> |{' '}
        <Link to="/dashboard/settings">Настройки</Link>
      </nav>
      <hr />
      <main>
        {/* Здесь будут рендериться дочерние компоненты */}
        <Outlet />
      </main>
    </div>
  );
}
\`\`\`

**2. Определяем вложенные маршруты в \`App.tsx\`:**

Чтобы создать вложенные маршруты, мы помещаем теги \`<Route>\` внутрь другого тега \`<Route>\`.

\`\`\`tsx
import { Routes, Route } from 'react-router-dom';
import DashboardLayout from './DashboardLayout';

// Компоненты для дочерних маршрутов
const DashboardHome = () => <h3>Добро пожаловать!</h3>;
const Profile = () => <h3>Ваш профиль</h3>;
const Settings = () => <h3>Настройки аккаунта</h3>;

function App() {
  return (
    <Routes>
      {/* Другие маршруты */}
      <Route path="/dashboard" element={<DashboardLayout />}>
        {/* Дочерние маршруты. Их element будет рендериться в <Outlet> */}
        <Route index element={<DashboardHome />} /> {/* 'index' означает, что это путь по умолчанию для /dashboard */}
        <Route path="profile" element={<Profile />} /> {/* Путь 'profile' будет /dashboard/profile */}
        <Route path="settings" element={<Settings />} />
      </Route>
    </Routes>
  );
}
\`\`\`
Теперь при навигации по ссылкам внутри \`/dashboard\`, компонент \`DashboardLayout\` будет оставаться на экране, а содержимое \`<Outlet />\` будет меняться.
        `,
    },
    {
        id: 'module-34',
        title: 'Модуль 34: Программная навигация',
        content: `
### Что такое программная навигация?

Иногда нам нужно перенаправить пользователя на другую страницу не по клику на ссылку \`<Link>\`, а в результате выполнения какого-то действия. Например, после успешной отправки формы или выхода из системы.

Такое перенаправление, выполненное с помощью кода, называется **программной навигацией**.

### Хук useNavigate

Для программной навигации React Router предоставляет хук \`useNavigate\`.

Он возвращает функцию, которую вы можете вызвать для перехода на другой маршрут.

**Как использовать:**
1.  Импортируйте \`useNavigate\` из \`react-router-dom\`.
2.  Вызовите хук в вашем компоненте, чтобы получить функцию навигации.
3.  Вызовите эту функцию с путем, на который нужно перейти.

### Пример: Логин форма

Представим форму входа, которая после успешной "аутентификации" должна перенаправить пользователя на его панель управления.

\`\`\`tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const [username, setUsername] = useState('');
  // 1. Получаем функцию навигации
  const navigate = useNavigate();

  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();
    // Имитация успешного входа
    if (username) {
      console.log(\`Пользователь \${username} вошел в систему.\`);
      // 2. Выполняем перенаправление на страницу /dashboard
      navigate('/dashboard');
    } else {
      alert('Пожалуйста, введите имя пользователя.');
    }
  };

  return (
    <form onSubmit={handleLogin}>
      <input
        type="text"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Введите имя"
      />
      <button type="submit">Войти</button>
    </form>
  );
}
\`\`\`

### Навигация назад

Функция \`navigate\` также может принимать число для навигации по истории браузера.
- \`navigate(-1)\`: Вернуться на предыдущую страницу.
- \`navigate(-2)\`: Вернуться на две страницы назад.
- \`navigate(1)\`: Перейти вперед (если возможно).

\`\`\`tsx
<button onClick={() => navigate(-1)}>Назад</button>
\`\`\`
        `,
    },
    {
        id: 'module-35',
        title: 'Модуль 35: Защищенные маршруты (Protected Routes)',
        content: `
### Что такое защищенный маршрут?

Во многих приложениях есть страницы, доступ к которым должен быть только у аутентифицированных (вошедших в систему) пользователей. Например, личный кабинет или панель администратора.

**Защищенный маршрут** — это специальный компонент, который проверяет, есть ли у пользователя доступ, и либо показывает запрошенную страницу, либо перенаправляет его на страницу входа.

### Реализация защищенного маршрута

Мы можем создать компонент-обертку, который будет выполнять эту проверку.

**1. Создаем компонент \`ProtectedRoute\`:**
Этот компонент будет принимать дочерний элемент (\`children\`) — ту страницу, которую мы хотим защитить.

\`\`\`tsx
import React from 'react';
import { Navigate } from 'react-router-dom';

// Имитация проверки аутентификации
// В реальном приложении это будет браться из контекста, Zustand или localStorage
const useAuth = () => {
  // Просто для примера, вернем false
  return { isAuthenticated: false };
};

interface ProtectedRouteProps {
  children: React.ReactNode;
}

function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    // Если пользователь не аутентифицирован, перенаправляем его на страницу входа
    // Компонент <Navigate> выполняет перенаправление
    return <Navigate to="/login" replace />; // 'replace' заменяет текущую запись в истории
  }

  // Если все в порядке, рендерим запрошенный дочерний компонент
  return children;
}

export default ProtectedRoute;
\`\`\`

**2. Используем \`ProtectedRoute\` в \`App.tsx\`:**
Теперь мы можем "обернуть" защищенные маршруты в наш новый компонент.

\`\`\`tsx
import { Routes, Route } from 'react-router-dom';
import ProtectedRoute from './ProtectedRoute';

const HomePage = () => <h2>Главная</h2>;
const LoginPage = () => <h2>Страница входа</h2>;
const DashboardPage = () => <h2>Секретная панель управления</h2>;

function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/login" element={<LoginPage />} />
      <Route
        path="/dashboard"
        element={
          <ProtectedRoute>
            <DashboardPage />
          </ProtectedRoute>
        }
      />
    </Routes>
  );
}
\`\`\`
Теперь, если неаутентифицированный пользователь попытается зайти на \`/dashboard\`, он будет автоматически перенаправлен на \`/login\`.
        `,
    },
    {
        id: 'module-36',
        title: 'Модуль 36: HTTP-запросы с Fetch API',
        content: `
### Взаимодействие с сервером

React-приложения часто получают данные с сервера через **API (Application Programming Interface)**. API — это набор правил, по которым программы общаются друг с другом. Обычно это происходит по протоколу **HTTP**.

**Fetch API** — это современный, встроенный в браузер механизм для выполнения HTTP-запросов. Он основан на **промисах (Promises)**.

### Промисы (Promises)

Промис — это объект, представляющий результат асинхронной операции. Он может находиться в одном из трех состояний:
- \`pending\` (ожидание): операция еще не завершена.
- \`fulfilled\` (выполнено): операция завершилась успешно.
- \`rejected\` (отклонено): операция завершилась с ошибкой.

Мы работаем с промисами с помощью методов \`.then()\` (для успеха) и \`.catch()\` (для ошибки) или с помощью синтаксиса \`async/await\`.

### GET-запрос с Fetch

GET-запрос используется для получения данных.

\`\`\`tsx
import React, { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // JSONPlaceholder - это бесплатный фейковый API для тестирования
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => {
        if (!response.ok) { // Проверяем, успешен ли ответ (статус 200-299)
          throw new Error('Сетевой ответ был не в порядке');
        }
        return response.json(); // .json() - это тоже асинхронная операция
      })
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error.message);
        setLoading(false);
      });
  }, []); // Пустой массив, чтобы запрос выполнился один раз

  if (loading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error}</p>;

  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
\`\`\`

### POST-запрос с Fetch

POST-запрос используется для отправки данных на сервер (например, для создания нового пользователя).

\`\`\`javascript
const newUser = { name: 'Новый Пользователь', email: 'new@example.com' };

fetch('https://jsonplaceholder.typicode.com/users', {
  method: 'POST', // Указываем метод
  headers: {
    'Content-Type': 'application/json', // Говорим серверу, что отправляем JSON
  },
  body: JSON.stringify(newUser), // Преобразуем объект в строку JSON
})
  .then(response => response.json())
  .then(data => console.log('Сервер ответил:', data))
  .catch(error => console.error('Ошибка:', error));
\`\`\`
        `,
    },
    {
        id: 'module-37',
        title: 'Модуль 37: Синтаксис async/await',
        content: `
### Упрощение работы с промисами

Синтаксис \`.then().catch()\` может стать громоздким, когда у вас несколько последовательных асинхронных операций (так называемый "callback hell").

**async/await** — это специальный синтаксис в JavaScript, который позволяет работать с промисами так, как будто это синхронный код. Он делает код более читаемым и простым.

### Как это работает?

- **\`async\`:** Ключевое слово \`async\` ставится перед объявлением функции. Оно означает, что эта функция всегда будет возвращать промис.
- **\`await\`:** Ключевое слово \`await\` можно использовать **только внутри \`async\` функции**. Оно заставляет JavaScript "подождать", пока промис не выполнится, и возвращает его результат.

### Пример: Переписываем GET-запрос с async/await

Сравните этот код с кодом из предыдущего модуля.

\`\`\`tsx
import React, { useEffect, useState } from 'react';

function UserListAsync() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Создаем async функцию внутри useEffect
    const fetchUsers = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        if (!response.ok) {
          throw new Error('Сетевой ответ был не в порядке');
        }
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        setError(error.message);
      } finally {
        // finally выполнится в любом случае (успех или ошибка)
        setLoading(false);
      }
    };

    fetchUsers(); // Вызываем ее
  }, []);

  if (loading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error}</p>;

  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
\`\`\`

### Обработка ошибок

Вместо \`.catch()\` мы используем стандартный блок **\`try...catch\`** для перехвата ошибок, которые могут возникнуть во время выполнения \`await\`.

- **\`try\`:** В этот блок помещается код, который может вызвать ошибку.
- **\`catch\`:** Этот блок выполняется, если в блоке \`try\` произошла ошибка.

Использование \`async/await\` является современным стандартом для работы с асинхронными операциями в JavaScript и React.
        `,
    },
    {
        id: 'module-38',
        title: 'Модуль 38: Введение в React Query (TanStack Query)',
        content: `
### Проблема с состоянием сервера

Когда мы загружаем данные с помощью \`useEffect\` и \`useState\`, мы сталкиваемся с множеством проблем, которые приходится решать вручную:
- **Кеширование:** Как не загружать одни и те же данные снова и снова?
- **Синхронизация:** Как обновить данные, если они изменились на сервере?
- **Состояние загрузки и ошибок:** Мы вручную создаем state-переменные для \`loading\` и \`error\`.
- **Пагинация, "бесконечная" прокрутка:** Реализация этих паттернов требует много сложного кода.

### Что такое React Query?

**React Query (теперь TanStack Query)** — это библиотека для управления **серверным состоянием (server state)**. Она берет на себя всю сложную работу по получению, кешированию, синхронизации и обновлению данных с сервера.

Это не замена \`useState\` или Zustand. React Query предназначен именно для данных, которые "живут" на сервере, а не для UI-состояния (например, открыто ли модальное окно).

### Хук useQuery

Основной хук в React Query — это \`useQuery\`. Он принимает два главных аргумента:

1.  **Ключ запроса (Query Key):** Уникальный идентификатор для этого запроса. Это массив. React Query использует его для кеширования.
2.  **Функция запроса (Query Function):** Асинхронная функция, которая получает данные (например, с помощью \`fetch\`).

\`useQuery\` возвращает объект со всей необходимой информацией о состоянии запроса.

### Пример: Переписываем загрузку пользователей

**1. Настройка провайдера (\`main.tsx\`):**
\`\`\`tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
);
\`\`\`

**2. Используем \`useQuery\` в компоненте:**
\`\`\`tsx
import React from 'react';
import { useQuery } from '@tanstack/react-query';

// Функция для получения данных
const fetchUsers = async () => {
  const response = await fetch('https://jsonplaceholder.typicode.com/users');
  if (!response.ok) {
    throw new Error('Сетевая ошибка');
  }
  return response.json();
};

function UserListWithRQ() {
  // Используем хук useQuery
  const { data, error, isLoading } = useQuery({
    queryKey: ['users'], // Уникальный ключ
    queryFn: fetchUsers, // Функция для запроса
  });

  if (isLoading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error.message}</p>;

  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
\`\`\`
Код стал намного чище! React Query автоматически управляет состоянием загрузки, ошибками и кешированием. Если вы перейдете на другую страницу, а потом вернетесь, данные будут взяты из кеша мгновенно, а в фоне будет запущен запрос для их обновления.
        `,
    },
    {
        id: 'module-39',
        title: 'Модуль 39: Мутации с React Query (useMutation)',
        content: `
### Что такое мутации?

Если \`useQuery\` используется для **чтения (GET)** данных, то для **изменения (POST, PUT, PATCH, DELETE)** данных на сервере используются **мутации**.

Мутация — это любая операция, которая изменяет данные на сервере.

### Хук useMutation

Хук \`useMutation\` предназначен для выполнения таких операций. Он похож на \`useQuery\`, но работает немного иначе.

- Он не запускается автоматически. Вы получаете функцию \`mutate\`, которую нужно вызвать, чтобы запустить мутацию.
- Он предоставляет состояния, связанные с процессом изменения данных: \`isLoading\`, \`isError\`, \`isSuccess\`.

### Пример: Добавление нового поста

**1. Создаем функцию для POST-запроса:**
\`\`\`ts
const createPost = async (newPost: { title: string; body: string; }) => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(newPost),
  });
  if (!response.ok) {
    throw new Error('Не удалось создать пост');
  }
  return response.json();
};
\`\`\`

**2. Используем \`useMutation\` в компоненте:**
\`\`\`tsx
import React, { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';

function AddPostForm() {
  const [title, setTitle] = useState('');
  const queryClient = useQueryClient(); // Получаем доступ к клиенту React Query

  const mutation = useMutation({
    mutationFn: createPost,
    onSuccess: () => {
      // Эта функция вызовется после успешной мутации
      console.log('Пост успешно создан!');
      // Инвалидируем кеш запроса 'posts', чтобы список постов обновился
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
    onError: (error: Error) => {
      console.error('Ошибка:', error.message);
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Вызываем мутацию, передавая ей данные
    mutation.mutate({ title, body: 'Тело поста' });
    setTitle('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Заголовок нового поста"
      />
      <button type="submit" disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Сохранение...' : 'Добавить пост'}
      </button>
    </form>
  );
}
\`\`\`
### Инвалидация кеша

Ключевой момент в примере — \`queryClient.invalidateQueries({ queryKey: ['posts'] })\`.

Эта команда говорит React Query: "Данные, связанные с ключом \`['posts']\`, устарели". React Query автоматически найдет все \`useQuery\` с этим ключом и выполнит для них повторный запрос, чтобы получить свежие данные с сервера. Это обеспечивает синхронизацию вашего UI с состоянием сервера.
        `,
    },
    {
        id: 'module-40',
        title: 'Модуль 40: Продвинутый TypeScript - типы и интерфейсы',
        content: `
### Разница между \`type\` и \`interface\`

В TypeScript для описания "формы" объектов мы можем использовать два ключевых слова: \`type\` и \`interface\`.

\`\`\`ts
// Используя interface
interface User {
  id: number;
  name: string;
}

// Используя type
type Product = {
  id: string;
  price: number;
};
\`\`\`
Для описания объектов они почти взаимозаменяемы. Однако есть ключевые различия:

- **Расширение (Extending):** \`interface\` может "наследоваться" от другого \`interface\`, в то время как \`type\` для этого использует пересечение (\`&\`).
  \`\`\`ts
  interface Admin extends User {
    role: 'admin';
  }

  type SuperProduct = Product & {
    isFeatured: boolean;
  };
  \`\`\`
- **Объединение (Union):** \`type\` может описывать объединение типов, а \`interface\` — нет.
  \`\`\`ts
  type Status = 'success' | 'error' | 'loading'; // OK
  // interface StatusInterface = 'success' | 'error'; // Ошибка
  \`\`\`
- **"Слияние" объявлений (Declaration Merging):** Если вы объявите два \`interface\` с одним и тем же именем, TypeScript объединит их. С \`type\` так сделать нельзя.
  \`\`\`ts
  interface Window {
    myApp: object;
  }
  interface Window {
    myVersion: string;
  }
  // Теперь глобальный объект window будет иметь оба свойства
  \`\`\`
**Рекомендация:** Используйте \`interface\` для описания формы объектов (props, состояние), а \`type\` для более сложных конструкций, таких как объединения.

### Утилитарные типы (Utility Types)

TypeScript предоставляет встроенные типы-утилиты, которые помогают создавать новые типы на основе существующих.

- **\`Partial<T>\`:** Делает все свойства типа \`T\` опциональными.
  \`\`\`ts
  type PartialUser = Partial<User>; // { id?: number; name?: string; }
  \`\`\`
- **\`Required<T>\`:** Делает все свойства типа \`T\` обязательными.
- **\`Readonly<T>\`:** Делает все свойства типа \`T\` доступными только для чтения.
- **\`Pick<T, K>\`:** Создает новый тип, выбирая только указанные свойства (\`K\`) из типа \`T\`.
  \`\`\`ts
  type UserName = Pick<User, 'name'>; // { name: string; }
  \`\`\`
- **\`Omit<T, K>\`:** Создает новый тип, исключая указанные свойства (\`K\`) из типа \`T\`.
  \`\`\`ts
  type UserId = Omit<User, 'name'>; // { id: number; }
  \`\`\`
Эти утилиты очень полезны для создания гибких и переиспользуемых типов в React-приложениях.
        `,
    },
    {
        id: 'module-41',
        title: 'Модуль 41: Введение в тестирование - Зачем и как?',
        content: `
### Зачем нужны тесты?

Написание тестов — это процесс создания кода, который проверяет, что другой ваш код работает правильно. Это может показаться дополнительной работой, но в долгосрочной перспективе тесты экономят огромное количество времени и нервов.

**Преимущества тестирования:**
1.  **Уверенность в коде:** Вы можете вносить изменения (проводить рефакторинг) и быть уверенными, что ничего не сломали.
2.  **Меньше багов:** Тесты помогают находить ошибки на ранней стадии разработки.
3.  **Документация:** Тесты служат живой документацией, показывая, как должен работать ваш код.
4.  **Улучшение архитектуры:** Код, который легко тестировать, обычно имеет более качественную и продуманную архитектуру.

### Виды тестов

- **Unit-тесты (Модульные тесты):** Проверяют самую маленькую "единицу" кода в изоляции, обычно одну функцию или один компонент. Они быстрые и их должно быть много.
- **Integration-тесты (Интеграционные тесты):** Проверяют, как несколько "единиц" работают вместе. Например, как форма отправляет данные при клике на кнопку.
- **End-to-End (E2E) тесты:** Проверяют все приложение целиком с точки зрения пользователя. Специальная программа (например, Cypress, Playwright) открывает браузер и имитирует действия пользователя: клики, ввод текста, переходы по страницам. Эти тесты медленные, но очень надежные.

### Инструменты для тестирования в React

- **Jest:** Самый популярный фреймворк для тестирования JavaScript. Он предоставляет среду для запуска тестов, функции для проверок (\`expect\`) и возможность создавать "моки" (заглушки).
- **React Testing Library (RTL):** Библиотека, которая помогает рендерить компоненты в тестовой среде и взаимодействовать с ними так, как это делал бы пользователь. Ее философия — "тестируй свой софт так, как его используют пользователи".
        `,
    },
    {
        id: 'module-42',
        title: 'Модуль 42: Unit-тестирование с Jest и React Testing Library',
        content: `
### Настройка окружения

Проекты, созданные с помощью Vite, уже имеют базовую настройку для тестирования с использованием Vitest (аналог Jest) и React Testing Library.

### Структура теста

Тесты обычно находятся в файлах с расширением \`.test.tsx\` или \`.spec.tsx\`.

Основной тест состоит из трех шагов (часто называют **AAA: Arrange, Act, Assert**):

1.  **Arrange (Подготовка):** Подготовка данных и рендеринг компонента.
2.  **Act (Действие):** Выполнение действия, которое мы хотим протестировать (клик, ввод текста).
3.  **Assert (Проверка):** Проверка того, что результат соответствует ожиданиям.

### Пример: Тестирование простого компонента

Давайте протестируем компонент, который показывает текст при клике на кнопку.

**Компонент (\`HiddenMessage.tsx\`):**
\`\`\`tsx
import React, { useState } from 'react';

function HiddenMessage({ children }) {
  const [showMessage, setShowMessage] = useState(false);
  return (
    <div>
      <button onClick={() => setShowMessage(true)}>Показать сообщение</button>
      {showMessage && <span>{children}</span>}
    </div>
  );
}
\`\`\`

**Тест (\`HiddenMessage.test.tsx\`):**
\`\`\`tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // для дополнительных проверок
import HiddenMessage from './HiddenMessage';

test('показывает сообщение при клике', () => {
  const testMessage = 'Секретный код: 1234';

  // 1. Arrange (Подготовка)
  render(<HiddenMessage>{testMessage}</HiddenMessage>);

  // Проверяем, что сообщения изначально НЕТ на экране
  expect(screen.queryByText(testMessage)).toBeNull();

  // Находим кнопку
  const showButton = screen.getByText('Показать сообщение');

  // 2. Act (Действие)
  fireEvent.click(showButton);

  // 3. Assert (Проверка)
  // Проверяем, что сообщение ПОЯВИЛОСЬ на экране
  expect(screen.getByText(testMessage)).toBeInTheDocument();
});
\`\`\`

### Ключевые функции React Testing Library

- \`render()\`: Рендерит компонент в тестовом DOM.
- \`screen\`: Объект с методами для поиска элементов на "экране" (\`getByText\`, \`getByRole\`, \`getByLabelText\` и т.д.).
- \`fireEvent\`: Объект с методами для имитации событий (\`fireEvent.click\`, \`fireEvent.change\`).
- \`expect().toBeInTheDocument()\`: Функция из \`@testing-library/jest-dom\` для проверки наличия элемента.
        `,
    },
    {
        id: 'module-43',
        title: 'Модуль 43: Мокинг (Mocking) в тестах',
        content: `
### Что такое мокинг?

Когда мы пишем **unit-тест**, мы хотим протестировать компонент в **изоляции**. Это означает, что мы не хотим, чтобы он зависел от внешних систем, таких как API, таймеры или другие модули.

**Мокинг (mocking)** — это процесс замены реальных зависимостей на "заглушки" или "моки", которые мы можем контролировать в наших тестах.

### Мокинг функций с Jest

Jest предоставляет мощные инструменты для создания мок-функций.

\`\`\`ts
test('вызывает колбэк при клике', () => {
  // 1. Создаем мок-функцию
  const handleClick = jest.fn();

  render(<Button onClick={handleClick}>Нажми</Button>);

  // 2. Имитируем клик
  fireEvent.click(screen.getByText('Нажми'));

  // 3. Проверяем, что наша мок-функция была вызвана
  expect(handleClick).toHaveBeenCalledTimes(1);
});
\`\`\`

### Мокинг API запросов

Самый частый случай мокинга — это замена реальных HTTP-запросов. Мы не хотим, чтобы наши тесты ходили в настоящую сеть. Это делает их медленными, нестабильными и зависимыми от состояния сервера.

Библиотека **Mock Service Worker (MSW)** является современным стандартом для мокинга API. Она перехватывает сетевые запросы на уровне сервис-воркера и позволяет вам возвращать заранее определенные ответы.

**Пример настройки MSW (упрощенно):**

**1. Определяем обработчики (\`mocks/handlers.ts\`):**
\`\`\`ts
import { rest } from 'msw';

export const handlers = [
  // Перехватываем GET-запрос на /users
  rest.get('/api/users', (req, res, ctx) => {
    // Отвечаем моковыми данными
    return res(
      ctx.status(200),
      ctx.json([
        { id: 1, name: 'Тестовый Пользователь' },
      ])
    );
  }),
];
\`\`\`

**2. Настраиваем сервер для тестов (\`setupTests.ts\`):**
\`\`\`ts
import { setupServer } from 'msw/node';
import { handlers } from './mocks/handlers';

const server = setupServer(...handlers);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
\`\`\`

**3. Пишем тест для компонента, который делает запрос:**
\`\`\`tsx
import { render, screen, waitFor } from '@testing-library/react';

test('отображает пользователей после загрузки', async () => {
  render(<UserList />);

  // Используем findBy, который ждет появления элемента
  const userItem = await screen.findByText('Тестовый Пользователь');
  expect(userItem).toBeInTheDocument();
});
\`\`\`
Теперь, когда \`UserList\` вызовет \`fetch('/api/users')\`, MSW перехватит этот запрос и вернет наши моковые данные, делая тест быстрым и предсказуемым.
        `,
    },
    {
        id: 'module-44',
        title: 'Модуль 44: Линтинг и форматирование (ESLint, Prettier)',
        content: `
### Зачем нужны линтеры и форматтеры?

Когда в команде работает несколько человек (или даже один, но над большим проектом), очень важно поддерживать **единый стиль кода (code style)**. Это делает код более читаемым и предсказуемым.

- **Линтер (Linter):** Это инструмент, который анализирует ваш код и находит потенциальные ошибки, баги и отклонения от правил стиля. **ESLint** — стандартный линтер для JavaScript и TypeScript.
- **Форматтер (Formatter):** Это инструмент, который автоматически переформатирует ваш код в соответствии с заданными правилами (отступы, кавычки, переносы строк). **Prettier** — самый популярный форматтер.

### ESLint

ESLint настраивается с помощью файла \`.eslintrc.json\` (или \`.js\`). В нем вы можете:
- Указывать наборы правил (например, рекомендованные правила для React).
- Включать или отключать конкретные правила.

**Пример правила:** \`"no-unused-vars": "warn"\` будет показывать предупреждение, если у вас есть неиспользуемые переменные.

Проекты, созданные с Vite, уже имеют базовую конфигурацию ESLint.

### Prettier

Prettier имеет очень мало настроек, потому что его философия — "один стиль, чтобы править всеми". Он берет на себя все решения о форматировании.

**Пример конфигурации (\`.prettierrc\`):**
\`\`\`json
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5"
}
\`\`\`
- \`semi\`: ставить ли точки с запятой.
- \`singleQuote\`: использовать ли одинарные кавычки.
- \`trailingComma\`: ставить ли "висячую" запятую.

### Интеграция с VS Code

Лучший способ использовать эти инструменты — интегрировать их в ваш редактор кода.
1.  Установите расширения **ESLint** и **Prettier - Code formatter** для VS Code.
2.  Настройте VS Code, чтобы он автоматически форматировал файлы при сохранении. Добавьте в ваш \`settings.json\`:
    \`\`\`json
    {
      "editor.formatOnSave": true,
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    }
    \`\`\`
Теперь при каждом сохранении файла Prettier будет автоматически его форматировать, а ESLint будет подсвечивать ошибки прямо в редакторе. Это сильно повышает качество и консистентность кода.
        `,
    },
    {
        id: 'module-45',
        title: 'Модуль 45: Сборка проекта для продакшена',
        content: `
### Разработка vs. Продакшн

- **Режим разработки (Development):** Когда вы запускаете \`npm run dev\`, Vite (или другой сборщик) запускает локальный сервер. Он оптимизирован для скорости: быстрая перезагрузка, source maps для отладки, подробные сообщения об ошибках. Код не сжат и не оптимизирован.
- **Режим продакшена (Production):** Когда ваше приложение готово к публикации, его нужно "собрать" для продакшена. Этот процесс оптимизирован для производительности: код сжимается, удаляется все ненужное, файлы кешируются.

### Команда сборки

В проектах Vite для сборки используется команда:
\`\`\`bash
npm run build
\`\`\`
Эта команда запускает процесс сборки и создает папку \`dist\` (сокращение от "distributable").

### Что происходит во время сборки?

1.  **Транспиляция:** Весь ваш TypeScript и JSX код преобразуется в обычный JavaScript, понятный всем браузерам.
2.  **Сборка бандлов (Bundling):** Все ваши JavaScript-файлы и зависимости из \`node_modules\` собираются в один или несколько оптимизированных файлов — "бандлов".
3.  **Минификация:** Из кода удаляются все пробелы, комментарии, а имена переменных сокращаются. Это значительно уменьшает размер файлов.
    - \`const userName = "Иван";\` превратится в \`const a="Иван";\`.
4.  **Оптимизация CSS:** CSS-файлы также объединяются и сжимаются.
5.  **Оптимизация ассетов:** Изображения и шрифты могут быть сжаты или оптимизированы.
6.  **Генерация HTML:** Создается финальный \`index.html\`, в который автоматически подключаются сгенерированные JS и CSS бандлы с уникальными именами (для кеширования).

### Папка \`dist\`

Содержимое папки \`dist\` — это и есть ваш готовый к публикации сайт. Это набор статичных файлов (HTML, CSS, JS, изображения), которые вы можете загрузить на любой хостинг.
        `,
    },
    {
        id: 'module-46',
        title: 'Модуль 46: Деплой приложения',
        content: `
### Что такое деплой?

**Деплой (Deployment)** — это процесс размещения вашего собранного приложения (папки \`dist\`) на веб-сервере, чтобы оно стало доступно пользователям в интернете.

### Хостинг для статичных сайтов

Так как результат сборки React-приложения — это набор статичных файлов, мы можем использовать специализированные хостинг-платформы, которые делают процесс деплоя очень простым.

Популярные сервисы:
- **Netlify**
- **Vercel**
- **GitHub Pages**

Эти сервисы предоставляют **непрерывную интеграцию и доставку (CI/CD)**.

### Непрерывный деплой (Continuous Deployment)

Это практика, при которой каждое изменение, которое вы отправляете (push) в ваш репозиторий на GitHub (или GitLab/Bitbucket), автоматически запускает процесс сборки и деплоя.

**Как это работает (на примере Netlify):**
1.  Вы регистрируетесь на Netlify и подключаете свой GitHub-аккаунт.
2.  Вы выбираете репозиторий с вашим React-приложением.
3.  Netlify автоматически определит, что это проект Vite, и предложит настройки:
    - **Build command (Команда сборки):** \`npm run build\`
    - **Publish directory (Папка для публикации):** \`dist\`
4.  Вы нажимаете "Deploy site". Netlify скопирует ваш код, выполнит команду сборки и развернет результат на уникальном URL (например, \`my-awesome-app.netlify.app\`).
5.  **Готово!** Теперь каждый раз, когда вы будете делать \`git push\` в основную ветку, Netlify будет автоматически повторять этот процесс и обновлять ваш сайт.

Этот подход избавляет от необходимости вручную собирать и загружать файлы на сервер, делая процесс разработки быстрым и надежным.
        `,
    },
    {
        id: 'module-47',
        title: 'Модуль 47: Использование библиотек компонентов (ZwheUI)',
        content: `
### Что такое библиотека компонентов?

**Библиотека компонентов (Component Library)** — это набор готовых, переиспользуемых React-компонентов (кнопки, поля ввода, модальные окна, таблицы и т.д.), которые уже стилизованы и имеют встроенную логику.

Использование такой библиотеки значительно ускоряет разработку, так как вам не нужно создавать все базовые элементы с нуля.

Примеры популярных библиотек: Material-UI (MUI), Ant Design, Chakra UI. **ZwheUI**, которую мы видим в этом демо, является примером такой библиотеки.

### Как использовать ZwheUI

**1. Установка (гипотетическая):**
\`\`\`bash
npm install zwhe-ui
\`\`\`

**2. Импорт и использование:**
Вы импортируете нужные компоненты и используете их в своем JSX, передавая им props для настройки.

\`\`\`tsx
import React, { useState } from 'react';
import { Button, Card, Input, Slider } from 'zwhe-ui';

function MyComponent() {
  const [value, setValue] = useState(50);

  return (
    <Card title="Моя карточка">
      <p>Это пример использования компонентов из библиотеки ZwheUI.</p>
      <Input label="Имя пользователя" placeholder="Введите ваше имя" />
      <Slider value={value} onChange={setValue} />
      <Button variant="primary" onClick={() => alert('Нажато!')}>
        Отправить
      </Button>
    </Card>
  );
}
\`\`\`

### Преимущества

- **Скорость разработки:** Вы быстро собираете интерфейс из готовых блоков.
- **Консистентность:** Все компоненты имеют единый дизайн, что делает ваше приложение целостным.
- **Доступность (Accessibility):** Хорошие библиотеки компонентов уже имеют встроенную поддержку ARIA-атрибутов и навигации с клавиатуры.
- **Качество:** Компоненты в популярных библиотеках хорошо протестированы и поддерживаются сообществом.

### Темизация

Большинство библиотек поддерживают **темизацию** — возможность настроить их внешний вид (цвета, шрифты, отступы) под ваш бренд, не переписывая CSS для каждого компонента.
        `,
    },
    {
        id: 'module-48',
        title: 'Модуль 48: Переменные окружения',
        content: `
### Что такое переменные окружения?

В приложении часто используются данные, которые не должны быть "зашиты" прямо в код. Особенно это касается конфиденциальной информации или настроек, которые меняются в зависимости от среды выполнения (разработка, продакшн).

- **API-ключи:** Секретные ключи для доступа к сторонним сервисам (например, Google Maps).
- **URL бэкенда:** Адрес вашего API-сервера (\`http://localhost:3001\` в разработке и \`https://api.myapp.com\` в продакшене).
- **Настройки:** Флаги для включения/отключения фич.

**Переменные окружения (Environment Variables)** — это переменные, которые задаются вне вашего кода, в среде, где он выполняется.

### Использование в Vite

Vite имеет встроенную поддержку переменных окружения через файлы \`.env\`.

1.  **Создайте файл \`.env.local\`** в корне вашего проекта. Этот файл **никогда не должен** попадать в Git (добавьте его в \`.gitignore\`).
2.  Добавьте в него переменные. **Важно:** В Vite переменные, доступные на клиенте, должны начинаться с префикса \`VITE_\`.

    \`\`\`
    # .env.local
    VITE_API_URL=http://localhost:8080/api
    VITE_GOOGLE_MAPS_API_KEY=AIza...
    \`\`\`

3.  **Используйте переменные в коде:**
    Vite делает эти переменные доступными через глобальный объект \`import.meta.env\`.

    \`\`\`tsx
    const apiUrl = import.meta.env.VITE_API_URL;
    console.log('API находится по адресу:', apiUrl);

    // Пример использования
    useEffect(() => {
      fetch(\`\${import.meta.env.VITE_API_URL}/users\`)
        .then(res => res.json())
        .then(data => console.log(data));
    }, []);
    \`\`\`

### Разные среды

Вы можете создавать разные \`.env\` файлы для разных сред:
- \`.env\`: Загружается во всех случаях.
- \`.env.development\`: Загружается только в режиме разработки.
- \`.env.production\`: Загружается только при сборке для продакшена.

Это позволяет, например, использовать тестовый API-ключ в разработке и боевой — в продакшене, не меняя код.
        `,
    },
    {
        id: 'module-49',
        title: 'Модуль 49: Сборка всех знаний - планирование проекта',
        content: `
Поздравляем! Вы прошли долгий путь и изучили все основные технологии и концепции современной frontend-разработки. Теперь пора собрать все эти знания воедино.

Лучший способ закрепить материал — создать собственный проект с нуля.

### Шаги по планированию проекта

1.  **Идея:** Придумайте идею для небольшого приложения. Это может быть:
    - Список дел (Todo List) с возможностью добавления, удаления, редактирования.
    - Приложение для погоды, которое получает данные с открытого API.
    - Простой блог или коллекция рецептов.
    - Каталог фильмов с поиском (используя, например, The Movie DB API).

2.  **Технологический стек:** Определите, какие инструменты вы будете использовать.
    - **Основа:** React + TypeScript (создано через Vite).
    - **Стилизация:** CSS Modules или CSS-in-JS (например, Styled Components).
    - **Роутинг:** React Router для создания нескольких страниц.
    - **Управление состоянием:**
      - \`useState\` для локального состояния.
      - \`useContext\` или **Zustand** для глобального UI-состояния (например, тема).
      - **React Query** для всего, что связано с серверными данными.
    - **Тестирование:** Jest/Vitest + React Testing Library для unit-тестов.

3.  **Декомпозиция:** Продумайте, на какие компоненты вы разобьете ваше приложение.
    - **Компоненты-страницы:** \`HomePage\`, \`PostPage\`, \`LoginPage\`.
    - **Переиспользуемые UI-компоненты:** \`Button\`, \`Input\`, \`Card\`, \`Spinner\`.
    - **Компоненты-контейнеры:** Компоненты, содержащие логику (например, получение данных) и передающие ее в "глупые" компоненты отображения.

4.  **API:** Найдите публичный API для вашей идеи или создайте простой мок-сервер (например, с помощью \`json-server\`), который будет отдавать вам данные.

5.  **План разработки (бэклог):** Разбейте большую задачу на маленькие шаги.
    - Шаг 1: Настроить проект.
    - Шаг 2: Создать базовую верстку главной страницы.
    - Шаг 3: Реализовать получение и отображение списка элементов.
    - Шаг 4: Добавить возможность создания нового элемента.
    - ... и так далее.

Этот структурированный подход поможет вам не растеряться и успешно довести проект до конца.
        `,
    },
    {
        id: 'module-50',
        title: 'Модуль 50: Куда двигаться дальше?',
        content: `
### Вы — frontend-разработчик!

Пройдя этот курс, вы получили прочную базу знаний, достаточную для того, чтобы начать свой путь в качестве Junior Frontend-разработчика. Вы умеете создавать интерактивные, современные веб-приложения на React.

Но мир веб-разработки огромен и постоянно меняется. Вот несколько направлений для дальнейшего роста:

#### 1. Углубление в React

- **Продвинутые паттерны:** Изучите рендер-пропсы, компоненты высшего порядка (HOC), хотя они и стали менее популярны с появлением хуков.
- **Оптимизация производительности:** Глубоко разберитесь с \`React.memo\`, \`useMemo\`, \`useCallback\`. Научитесь использовать React DevTools Profiler для поиска узких мест.
- **Анимации:** Изучите библиотеки для анимаций, такие как \`Framer Motion\` или \`React Spring\`.

#### 2. Фреймворки поверх React

React — это библиотека. Фреймворки, построенные на его основе, предоставляют готовые решения для многих задач (роутинг, рендеринг на сервере, оптимизация).
- **Next.js:** Самый популярный фреймворк. Предоставляет рендеринг на стороне сервера (SSR), статическую генерацию сайтов (SSG), роутинг на основе файловой системы и многое другое. **Обязателен к изучению для серьезной разработки на React.**
- **Remix:** Еще один мощный фулстек-фреймворк, сфокусированный на веб-стандартах.

#### 3. Углубление в экосистему

- **Тестирование:** Освойте E2E-тестирование с **Cypress** или **Playwright**.
- **Сборка:** Изучите, как работает Webpack или Vite "под капотом".
- **Storybook:** Научитесь создавать изолированные "витрины" для ваших UI-компонентов.

#### 4. Развитие в смежных областях

- **Backend:** Изучите Node.js и Express, чтобы создавать свои собственные API.
- **DevOps:** Разберитесь с Docker, CI/CD (GitHub Actions) на более глубоком уровне.

**Главное — продолжайте практиковаться, создавайте проекты и никогда не переставайте учиться! Удачи!**
        `,
    } 
];

export const ExampleGuideRu = () => (
    <Sofa>
        <Stack gap="1.5rem">
            <Text as="h2" size="1.875rem" weight="700">Полный курс по Frontend-разработке на React</Text>
            <Text color="textSecondary">Подробное руководство для начинающих, от основ HTML до создания современных веб-приложений.</Text>
            <Accordion defaultValue="module-1">
                {modules.map(mod => (
                    <AccordionItem value={mod.id} key={mod.id}>
                        <AccordionTrigger>
                            <Text weight="600">{mod.title}</Text>
                        </AccordionTrigger>
                        <AccordionContent>
                            <Markdown>{mod.content}</Markdown>
                        </AccordionContent>
                    </AccordionItem>
                ))}
            </Accordion>
        </Stack>
    </Sofa>
);
